enum SampleEnum = A | B;
enum SampleEnumWithCustValue = A = "foo" | B = 1;

scalar ZoneId;

record SimpleRecord_KeyVersion {
    @id key: string
    @rev version: string
}

record SimpleRecord_KeyVersion_Int_Int {
    @id key: int
    @rev version: int
}

record SimpleRecord {
    @id key: string
    @rev version: string

		value: string
}

record SimpleRecord_Basic {
    valueBoolean: boolean
		valueShort: short
		valueInt: int
		valueLong: long
		valueFloat: float
		valueDouble: double
		valueString: string
		valueLocalDate: local-date
		valueLocalDateTime: local-date-time
		valueZonedDateTime: zoned-date-time
}

record SimpleRecord_Basic_Optional {
    valueBoolean?: boolean
		valueShort?: short
		valueInt?: int
		valueLong?: long
		valueFloat?: float
		valueDouble?: double
		valueString?: string
		valueLocalDate?: local-date
		valueLocalDateTime?: local-date-time
		valueZonedDateTime?: zoned-date-time
}

record SimpleRecord_Basic_Null {
    valueBoolean: boolean?
		valueShort: short?
		valueInt: int?
		valueLong: long?
		valueFloat: float?
		valueDouble: double?
		valueString: string?
		valueLocalDate: local-date?
		valueLocalDateTime: local-date-time?
		valueZonedDateTime: zoned-date-time?
}

record SimpleRecord_Basic_Optional_Null {
    valueBoolean?: boolean?
		valueShort?: short?
		valueInt?: int?
		valueLong?: long?
		valueFloat?: float?
		valueDouble?: double?
		valueString?: string?
		valueLocalDate?: local-date?
		valueLocalDateTime?: local-date-time?
		valueZonedDateTime?: zoned-date-time?
}

record SimpleRecord_Basic_List {
	valueBoolean: boolean[]
	valueShort: short[]
	valueInt: int[]
	valueLong: long[]
	valueFloat: float[]
	valueDouble: double[]
	valueString: string[]
	valueLocalDate: local-date[]
	valueLocalDateTime: local-date-time[]
	valueZonedDateTime: zoned-date-time[]
}

record SimpleRecord_Basic_List_Optional {
	valueBoolean?: boolean[]
	valueShort?: short[]
	valueInt?: int[]
	valueLong?: long[]
	valueFloat?: float[]
	valueDouble?: double[]
	valueString?: string[]
	valueLocalDate?: local-date[]
	valueLocalDateTime?: local-date-time[]
	valueZonedDateTime?: zoned-date-time[]
}

record SimpleRecord_Basic_List_Null {
	valueBoolean: boolean[]?
	valueShort: short[]?
	valueInt: int[]?
	valueLong: long[]?
	valueFloat: float[]?
	valueDouble: double[]?
	valueString: string[]?
	valueLocalDate: local-date[]?
	valueLocalDateTime: local-date-time[]?
	valueZonedDateTime: zoned-date-time[]?
}

record SimpleRecord_Basic_List_Optional_Null {
	valueBoolean?: boolean[]?
	valueShort?: short[]?
	valueInt?: int[]?
	valueLong?: long[]?
	valueFloat?: float[]?
	valueDouble?: double[]?
	valueString?: string[]?
	valueLocalDate?: local-date[]?
	valueLocalDateTime?: local-date-time[]?
	valueZonedDateTime?: zoned-date-time[]?
}

record EnumRecord {
	value: SampleEnum
	value_Null: SampleEnum?
	value_Opt?: SampleEnum
	value_Opt_Null?: SampleEnum?
	
	list: SampleEnum[]
	list_Null: SampleEnum[]?
	list_Opt?: SampleEnum[]
	list_Opt_Null?: SampleEnum[]?
}

record EnumInlineRecord {
	value: enum A | B
	value_Null: enum C | D?
	value_Opt?: enum E | F
	value_Opt_Null?: enum G | H ?

	list: enum A | B []
	list_Null: enum C | D []?
	// Need to fix Grammer list_Opt?: enum E | F [],
	list_Opt_Null?: enum G | H []?
}

record ScalarRecord {
	value: ZoneId
	value_Null: ZoneId?
	value_Opt?: ZoneId
	value_Opt_Null?: ZoneId?
	
	list: ZoneId[]
	list_Null: ZoneId[]?
	list_Opt?: ZoneId[]
	list_Opt_Null?: ZoneId[]?
}

record RecordOfRecords {
	value: SimpleRecord_Basic
	value_Null: SimpleRecord_Basic?
	value_Opt?: SimpleRecord_Basic
	value_Opt_Null?: SimpleRecord_Basic?

	list: SimpleRecord_Basic[]
	list_Null: SimpleRecord_Basic[]?
	list_Opt?: SimpleRecord_Basic[]
	list_Opt_Null?: SimpleRecord_Basic[]?
}

record RecordWithUnions {
	value: Union
	value_Null: Union?
	value_Opt?: Union
	value_Opt_Null?: Union?

	list: Union[]
	list_Null: Union[]?
	list_Opt?: Union[]
	list_Opt_Null?: Union[]?
}

record UnionA {
	shared: string
	valueA: string
}

record UnionB {
	shared: string
	valueB: string
}

union Union = UnionA('union-a') | UnionB('union-b');

patchable record PatchableRecord {
    @id key: string
    @rev version: string

		value: string
}

patchable record PatchableRecord_Basic {
    @id key: string
    @rev version: string
	
    valueBoolean: boolean
		valueShort: short
		valueInt: int
		valueLong: long
		valueFloat: float
		valueDouble: double
		valueString: string
		valueLocalDate: local-date
		valueLocalDateTime: local-date-time
		valueZonedDateTime: zoned-date-time
}

patchable record PatchableRecord_Basic_Optional {
    @id key: string
    @rev version: string

    valueBoolean?: boolean
		valueShort?: short
		valueInt?: int
		valueLong?: long
		valueFloat?: float
		valueDouble?: double
		valueString?: string
		valueLocalDate?: local-date
		valueLocalDateTime?: local-date-time
		valueZonedDateTime?: zoned-date-time
}

patchable record PatchableRecord_Basic_Null {
    @id key: string
    @rev version: string

    valueBoolean: boolean?
		valueShort: short?
		valueInt: int?
		valueLong: long?
		valueFloat: float?
		valueDouble: double?
		valueString: string?
		valueLocalDate: local-date?
		valueLocalDateTime: local-date-time?
		valueZonedDateTime: zoned-date-time?
}

patchable record PatchableRecord_Basic_Optional_Null {
    @id key: string
    @rev version: string

    valueBoolean?: boolean?
		valueShort?: short?
		valueInt?: int?
		valueLong?: long?
		valueFloat?: float?
		valueDouble?: double?
		valueString?: string?
		valueLocalDate?: local-date?
		valueLocalDateTime?: local-date-time?
		valueZonedDateTime?: zoned-date-time?
}

patchable record PatchableRecord_Basic_List {
	@id key: string
	@rev version: string
	
	valueBoolean: boolean[]
	valueShort: short[]
	valueInt: int[]
	valueLong: long[]
	valueFloat: float[]
	valueDouble: double[]
	valueString: string[]
	valueLocalDate: local-date[]
	valueLocalDateTime: local-date-time[]
	valueZonedDateTime: zoned-date-time[]
}

patchable record PatchableRecord_Basic_List_Optional {
	@id key: string
	@rev version: string

	valueBoolean?: boolean[]
	valueShort?: short[]
	valueInt?: int[]
	valueLong?: long[]
	valueFloat?: float[]
	valueDouble?: double[]
	valueString?: string[]
	valueLocalDate?: local-date[]
	valueLocalDateTime?: local-date-time[]
	valueZonedDateTime?: zoned-date-time[]
}

patchable record PatchableRecord_Basic_List_Null {
	@id key: string
	@rev version: string

	valueBoolean: boolean[]?
	valueShort: short[]?
	valueInt: int[]?
	valueLong: long[]?
	valueFloat: float[]?
	valueDouble: double[]?
	valueString: string[]?
	valueLocalDate: local-date[]?
	valueLocalDateTime: local-date-time[]?
	valueZonedDateTime: zoned-date-time[]?
}

patchable record PatchableRecord_Basic_List_Optional_Null {
	@id key: string
	@rev version: string

	valueBoolean?: boolean[]?
	valueShort?: short[]?
	valueInt?: int[]?
	valueLong?: long[]?
	valueFloat?: float[]?
	valueDouble?: double[]?
	valueString?: string[]?
	valueLocalDate?: local-date[]?
	valueLocalDateTime?: local-date-time[]?
	valueZonedDateTime?: zoned-date-time[]?
}

patchable record PatchableEnumRecord {
	@id key: string
	@rev version: string

	value: SampleEnum
	value_Null: SampleEnum?
	value_Opt?: SampleEnum
	value_Opt_Null?: SampleEnum?
	
	list: SampleEnum[]
	list_Null: SampleEnum[]?
	list_Opt?: SampleEnum[]
	list_Opt_Null?: SampleEnum[]?
}

patchable record PatchableEnumInlineRecord {
	@id key: string
	@rev version: string

	value: enum A | B
	value_Null: enum C | D?
	value_Opt?: enum E | F
	value_Opt_Null?: enum G | H ?

	list: enum A | B []
	list_Null: enum C | D []?
	// Need to fix Grammer list_Opt?: enum E | F [],
	list_Opt_Null?: enum G | H []?
}

patchable record PatchableScalarRecord {
	@id key: string
	@rev version: string

	value: ZoneId
	value_Null: ZoneId?
	value_Opt?: ZoneId
	value_Opt_Null?: ZoneId?
	
	list: ZoneId[]
	list_Null: ZoneId[]?
	list_Opt?: ZoneId[]
	list_Opt_Null?: ZoneId[]?
}

patchable record PatchableRecordOfRecords {
	@id key: string
	@rev version: string

	value: PatchableRecord_Basic
	value_Null: PatchableRecord_Basic?
	value_Opt?: PatchableRecord_Basic
	value_Opt_Null?: PatchableRecord_Basic?

	list: PatchableRecord_Basic[]
	list_Null: PatchableRecord_Basic[]?
	list_Opt?: PatchableRecord_Basic[]
	list_Opt_Null?: PatchableRecord_Basic[]?
}

patchable record PatchableRecordWithUnion {
	@id key: string
	@rev version: string

	value: PatchableUnion
	value_Null: PatchableUnion?
	value_Opt?: PatchableUnion
	value_Opt_Null?: PatchableUnion?

	list: PatchableUnion[]
	list_Null: PatchableUnion[]?
	list_Opt?: PatchableUnion[]
	list_Opt_Null?: PatchableUnion[]?
}

patchable record PatchableUnionA {
	@id key: string
	@rev version: string

	shared: string
	valueA: string
}

patchable record PatchableUnionB {
	@id key: string
	@rev version: string

	shared: string
	valueB: string
}

union PatchableUnion = PatchableUnionA('union-a') | PatchableUnionB('union-b');

// TODO Mixed Union

mixin SimpleMixin {
	mValueString: string
}

mixin SimpleMixin2 {
	mValueString2: string
}

mixin UnionMixin {
	myUnion: Union
}

mixin RecordMixin {
	myRecord: SimpleRecord
}

record MixinRecord {
    include SimpleMixin
		include SimpleMixin2
		include UnionMixin
		include RecordMixin

    sample: string
}

/*record Node {
	parent?: Node[]
	children: Node[]
}*/

error SampleError;
error SampleError2;


service SampleService {
		operation getBoolean(): boolean;
		operation getShort(): short;
		operation getInt(): int;
		operation getLong(): long;
		operation getFloat(): float;
		operation getDouble(): double;
		operation getString(): string;
		operation getLocalDate(): local-date;
		operation getLocalDateTime(): local-date-time;
		operation getZonedDateTime(): zoned-date-time;
		operation getScalar(): ZoneId;
		operation getEnum(): SampleEnum;

		operation voidOperation();
		operation errorOperation() throws SampleError;
		operation multiErrorOperation() throws SampleError SampleError2;
		
		operation getSimpleRecord(key: string): SimpleRecord;
		operation getSimpleRecordWithError(key: string): SimpleRecord throws SampleError;
}

service ListSampleService {
		operation listBoolean(): boolean[];
		operation listShort(): short[];
		operation listInt(): int[];
		operation listLong(): long[];
		operation listFloat(): float[];
		operation listDouble(): double[];
		operation listString(): string[];
		operation listLocalDate(): local-date[];
		operation listLocalDateTime(): local-date-time[];
		operation listZonedDateTime(): zoned-date-time[];
		operation listScalar(): ZoneId[];
		operation listEnum(): SampleEnum[];

		operation listSimpleRecord(): SimpleRecord[];
		operation listSimpleRecordWithError(): SimpleRecord[] throws SampleError;
}


service PathParameterTypeService {
	operation simpleBooleanPathParam(
		pathBoolean: boolean
	): boolean;
	operation simpleShortPathParam(
		pathShort: short
	): short;
	operation simpleIntPathParam(
		pathInt: int
	): int;
	operation simpleLongPathParam(
		pathLong: long
	): long;
	operation simpleFloatPathParam(
		pathFloat: float
	): float;
	operation simpleDoublePathParam(
		pathDouble: double
	): double;
	operation simpleStringPathParam(
		pathString: string
	): string;
	operation simpleLocalDatePathParam(
		pathLocalDate: local-date
	): local-date;
	operation simpleLocalDateTimePathParam(
		pathLocalDateTime: local-date-time
	): local-date-time;
	operation simpleZonedDateTimePathParam(
		pathZonedDateTime: zoned-date-time
	): zoned-date-time;
	operation simpleScalarPathParam(
		pathScalar: ZoneId
	): ZoneId;
	operation simpleEnumPathParam(
		pathEnum: SampleEnum
	): SampleEnum;
	operation multiPathParam(valueA: string, valueB: int): string;
}

service BodyParameterTypes {
	operation simpleBooleanBodyParam(
		bodyBoolean: boolean
	);
	operation simpleShortBodyParam(
		bodyShort: short
	);
	operation simpleIntBodyParam(
		bodyInt: int
	);
	operation simpleLongBodyParam(
		bodyLong: long
	);
	operation simpleFloatBodyParam(
		bodyFloat: float
	);
	operation simpleDoubleBodyParam(
		bodyDouble: double
	);
	operation simpleStringBodyParam(
		bodyString: string
	);
	operation simpleLocalDateBodyParam(
		bodyLocalDate: local-date
	);
	operation simpleLocalDateTimeBodyParam(
		bodyLocalDateTime: local-date-time
	);
	operation simpleZonedDateTimeBodyParam(
		bodyZonedDateTime: zoned-date-time
	);
	operation simpleScalarBodyParam(
		bodyScalar: ZoneId
	);
}
