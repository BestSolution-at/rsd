// Generated by RSD - Do not modify
import {
	decodeResponse,
	encodeValue,
	encodingType,
	ifDefined,
	safeExecute,
	type ServiceProps,
} from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createQueryParameterTypesService(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService {
	return {
		simpleBooleanQueryParam: fnSimpleBooleanQueryParam(props),
		simpleBooleanQueryParamOpt: fnSimpleBooleanQueryParamOpt(props),
		simpleShortQueryParam: fnSimpleShortQueryParam(props),
		simpleShortQueryParamOpt: fnSimpleShortQueryParamOpt(props),
		simpleIntQueryParam: fnSimpleIntQueryParam(props),
		simpleIntQueryParamOpt: fnSimpleIntQueryParamOpt(props),
		simpleLongQueryParam: fnSimpleLongQueryParam(props),
		simpleLongQueryParamOpt: fnSimpleLongQueryParamOpt(props),
		simpleFloatQueryParam: fnSimpleFloatQueryParam(props),
		simpleFloatQueryParamOpt: fnSimpleFloatQueryParamOpt(props),
		simpleDoubleQueryParam: fnSimpleDoubleQueryParam(props),
		simpleDoubleQueryParamOpt: fnSimpleDoubleQueryParamOpt(props),
		simpleStringQueryParam: fnSimpleStringQueryParam(props),
		simpleStringQueryParamOpt: fnSimpleStringQueryParamOpt(props),
		simpleLocalDateQueryParam: fnSimpleLocalDateQueryParam(props),
		simpleLocalDateQueryParamOpt: fnSimpleLocalDateQueryParamOpt(props),
		simpleLocalDateTimeQueryParam: fnSimpleLocalDateTimeQueryParam(props),
		simpleLocalDateTimeQueryParamOpt: fnSimpleLocalDateTimeQueryParamOpt(props),
		simpleZonedDateTimeQueryParam: fnSimpleZonedDateTimeQueryParam(props),
		simpleZonedDateTimeQueryParamOpt: fnSimpleZonedDateTimeQueryParamOpt(props),
		simpleScalarQueryParam: fnSimpleScalarQueryParam(props),
		simpleScalarQueryParamOpt: fnSimpleScalarQueryParamOpt(props),
		simpleEnumQueryParam: fnSimpleEnumQueryParam(props),
		simpleEnumQueryParamOpt: fnSimpleEnumQueryParamOpt(props),
		multiQueryParam: fnMultiQueryParam(props),
		multiQueryParamOpt: fnMultiQueryParamOpt(props),
		recordQueryParam: fnRecordQueryParam(props),
		recordQueryParamOpt: fnRecordQueryParamOpt(props),
	};
}
function fnSimpleBooleanQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleBooleanQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleBooleanQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isBoolean);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanQueryParam');
		}
	};
}

function fnSimpleBooleanQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleBooleanQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleBooleanQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanQueryParamOpt');
		}
	};
}

function fnSimpleShortQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleShortQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number) => {
		try {
			const $init = (await preFetch?.('simpleShortQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleShortQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortQueryParam');
		}
	};
}

function fnSimpleShortQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleShortQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: number) => {
		try {
			const $init = (await preFetch?.('simpleShortQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleShortQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortQueryParamOpt');
		}
	};
}

function fnSimpleIntQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleIntQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number) => {
		try {
			const $init = (await preFetch?.('simpleIntQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleIntQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntQueryParam');
		}
	};
}

function fnSimpleIntQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleIntQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: number) => {
		try {
			const $init = (await preFetch?.('simpleIntQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleIntQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntQueryParamOpt');
		}
	};
}

function fnSimpleLongQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLongQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number) => {
		try {
			const $init = (await preFetch?.('simpleLongQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleLongQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongQueryParam');
		}
	};
}

function fnSimpleLongQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLongQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: number) => {
		try {
			const $init = (await preFetch?.('simpleLongQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleLongQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongQueryParamOpt');
		}
	};
}

function fnSimpleFloatQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleFloatQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleFloatQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatQueryParam');
		}
	};
}

function fnSimpleFloatQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleFloatQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleFloatQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatQueryParamOpt');
		}
	};
}

function fnSimpleDoubleQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleDoubleQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', String(queryValue));
			const $path = `${baseUrl}/api/queryparametertypes/simpleDoubleQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleQueryParam');
		}
	};
}

function fnSimpleDoubleQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleDoubleQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleDoubleQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleQueryParamOpt');
		}
	};
}

function fnSimpleStringQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleStringQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string) => {
		try {
			const $init = (await preFetch?.('simpleStringQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleStringQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringQueryParam');
		}
	};
}

function fnSimpleStringQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleStringQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: string) => {
		try {
			const $init = (await preFetch?.('simpleStringQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleStringQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringQueryParamOpt');
		}
	};
}

function fnSimpleLocalDateQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLocalDateQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleLocalDateQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateQueryParam');
		}
	};
}

function fnSimpleLocalDateQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLocalDateQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleLocalDateQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateQueryParamOpt');
		}
	};
}

function fnSimpleLocalDateTimeQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLocalDateTimeQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleLocalDateTimeQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeQueryParam');
		}
	};
}

function fnSimpleLocalDateTimeQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleLocalDateTimeQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleLocalDateTimeQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeQueryParamOpt');
		}
	};
}

function fnSimpleZonedDateTimeQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleZonedDateTimeQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleZonedDateTimeQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeQueryParam');
		}
	};
}

function fnSimpleZonedDateTimeQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleZonedDateTimeQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleZonedDateTimeQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeQueryParamOpt');
		}
	};
}

function fnSimpleScalarQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleScalarQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleScalarQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarQueryParam');
		}
	};
}

function fnSimpleScalarQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleScalarQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleScalarQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarQueryParamOpt');
		}
	};
}

function fnSimpleEnumQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleEnumQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', queryValue);
			const $path = `${baseUrl}/api/queryparametertypes/simpleEnumQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isSampleEnum);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumQueryParam');
		}
	};
}

function fnSimpleEnumQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['simpleEnumQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', v);
			});
			const $path = `${baseUrl}/api/queryparametertypes/simpleEnumQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumQueryParamOpt');
		}
	};
}

function fnMultiQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['multiQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string, valueB: number) => {
		try {
			const $init = (await preFetch?.('multiQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('valueA', valueA);
			$param.append('valueB', String(valueB));
			const $path = `${baseUrl}/api/queryparametertypes/multiQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiQueryParam');
		}
	};
}

function fnMultiQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['multiQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA?: string, valueB?: number) => {
		try {
			const $init = (await preFetch?.('multiQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(valueA, v => {
				$param.append('valueA', v);
			});
			ifDefined(valueB, v => {
				$param.append('valueB', String(v));
			});
			const $path = `${baseUrl}/api/queryparametertypes/multiQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiQueryParamOpt');
		}
	};
}

function fnRecordQueryParam(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['recordQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('queryValue', encodeValue(encodingType(props), api.model.SimpleRecordToJSON(queryValue)));
			const $path = `${baseUrl}/api/queryparametertypes/recordQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord);
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('recordQueryParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordQueryParam');
		}
	};
}

function fnRecordQueryParamOpt(
	props: ServiceProps<api.service.ErrorType>,
): api.service.QueryParameterTypesService['recordQueryParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue?: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordQueryParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			ifDefined(queryValue, v => {
				$param.append('queryValue', encodeValue(encodingType(props), api.model.SimpleRecordToJSON(v)));
			});
			const $path = `${baseUrl}/api/queryparametertypes/recordQueryParamOpt?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult);
				return safeExecute(api.result.OK($data), () => onSuccess?.('recordQueryParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordQueryParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordQueryParamOpt');
		}
	};
}
