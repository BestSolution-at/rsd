// Generated by RSD - Do not modify
import { decodeResponse, encodeValue, encodingType, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

function isListInlineEnumQueryParamResult(value: unknown): value is 'A' | 'B' {
	return value === 'A' || value === 'B';
}

export function createListQueryParameterTypesService(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService {
	return {
		listBooleanQueryParam: fnListBooleanQueryParam(props),
		listShortQueryParam: fnListShortQueryParam(props),
		listIntQueryParam: fnListIntQueryParam(props),
		listLongQueryParam: fnListLongQueryParam(props),
		listFloatQueryParam: fnListFloatQueryParam(props),
		listDoubleQueryParam: fnListDoubleQueryParam(props),
		listStringQueryParam: fnListStringQueryParam(props),
		listLocalDateQueryParam: fnListLocalDateQueryParam(props),
		listLocalDateTimeQueryParam: fnListLocalDateTimeQueryParam(props),
		listZonedDateTimeQueryParam: fnListZonedDateTimeQueryParam(props),
		listScalarQueryParam: fnListScalarQueryParam(props),
		listEnumQueryParam: fnListEnumQueryParam(props),
		listInlineEnumQueryParam: fnListInlineEnumQueryParam(props),
		listMultiQueryParam: fnListMultiQueryParam(props),
		listRecordQueryParam: fnListRecordQueryParam(props),
	};
}
function fnListBooleanQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listBooleanQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: boolean[]) => {
		try {
			const $init = (await preFetch?.('listBooleanQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listBooleanQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isBoolean));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listBooleanQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listBooleanQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listBooleanQueryParam');
		}
	};
}

function fnListShortQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listShortQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number[]) => {
		try {
			const $init = (await preFetch?.('listShortQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listShortQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listShortQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listShortQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listShortQueryParam');
		}
	};
}

function fnListIntQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listIntQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number[]) => {
		try {
			const $init = (await preFetch?.('listIntQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listIntQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listIntQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listIntQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listIntQueryParam');
		}
	};
}

function fnListLongQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listLongQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number[]) => {
		try {
			const $init = (await preFetch?.('listLongQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listLongQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLongQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLongQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLongQueryParam');
		}
	};
}

function fnListFloatQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listFloatQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number[]) => {
		try {
			const $init = (await preFetch?.('listFloatQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listFloatQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listFloatQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listFloatQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listFloatQueryParam');
		}
	};
}

function fnListDoubleQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listDoubleQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: number[]) => {
		try {
			const $init = (await preFetch?.('listDoubleQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', String($entry));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listDoubleQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listDoubleQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listDoubleQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listDoubleQueryParam');
		}
	};
}

function fnListStringQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listStringQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string[]) => {
		try {
			const $init = (await preFetch?.('listStringQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listStringQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listStringQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listStringQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listStringQueryParam');
		}
	};
}

function fnListLocalDateQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listLocalDateQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string[]) => {
		try {
			const $init = (await preFetch?.('listLocalDateQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listLocalDateQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDateQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDateQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDateQueryParam');
		}
	};
}

function fnListLocalDateTimeQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listLocalDateTimeQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string[]) => {
		try {
			const $init = (await preFetch?.('listLocalDateTimeQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listLocalDateTimeQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDateTimeQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDateTimeQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDateTimeQueryParam');
		}
	};
}

function fnListZonedDateTimeQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listZonedDateTimeQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string[]) => {
		try {
			const $init = (await preFetch?.('listZonedDateTimeQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listZonedDateTimeQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listZonedDateTimeQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listZonedDateTimeQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listZonedDateTimeQueryParam');
		}
	};
}

function fnListScalarQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listScalarQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: string[]) => {
		try {
			const $init = (await preFetch?.('listScalarQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listScalarQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listScalarQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listScalarQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listScalarQueryParam');
		}
	};
}

function fnListEnumQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listEnumQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: api.model.SampleEnum[]) => {
		try {
			const $init = (await preFetch?.('listEnumQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listEnumQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.model.isSampleEnum));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listEnumQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listEnumQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listEnumQueryParam');
		}
	};
}

function fnListInlineEnumQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listInlineEnumQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: ('A' | 'B')[]) => {
		try {
			const $init = (await preFetch?.('listInlineEnumQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', $entry);
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listInlineEnumQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, isListInlineEnumQueryParamResult));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listInlineEnumQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listInlineEnumQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listInlineEnumQueryParam');
		}
	};
}

function fnListMultiQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listMultiQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string[], valueB: number[], valueC: api.model.SimpleRecord[]) => {
		try {
			const $init = (await preFetch?.('listMultiQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			valueA.forEach($entry => {
				$param.append('valueA', $entry);
			});
			valueB.forEach($entry => {
				$param.append('valueB', String($entry));
			});
			valueC.forEach($entry => {
				$param.append('valueC', encodeValue(encodingType(props), api.model.SimpleRecordToJSON($entry)));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listMultiQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('listMultiQueryParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listMultiQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listMultiQueryParam');
		}
	};
}

function fnListRecordQueryParam(props: ServiceProps<api.service.ErrorType>): api.service.ListQueryParameterTypesService['listRecordQueryParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (queryValue: api.model.SimpleRecord[]) => {
		try {
			const $init = (await preFetch?.('listRecordQueryParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $param = new URLSearchParams();
			queryValue.forEach($entry => {
				$param.append('queryValue', encodeValue(encodingType(props), api.model.SimpleRecordToJSON($entry)));
			});
			const $path = `${baseUrl}/api/listqueryparametertypes/listRecordQueryParam?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isRecord));
				const $result = $data.map(api.model.SimpleRecordFromJSON);
				return safeExecute(api.result.OK($result), () => onSuccess?.('listRecordQueryParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listRecordQueryParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listRecordQueryParam');
		}
	};
}

