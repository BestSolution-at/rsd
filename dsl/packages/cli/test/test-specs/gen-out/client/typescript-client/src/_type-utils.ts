// Generated by RSD - Do not modify
type Guard<T> = (value: unknown) => value is T;

export function isDefined<T>(value: T | undefined): value is T {
	return value !== undefined;
}

export function isUndefined(value: unknown): value is undefined {
	return value === undefined;
}

export function isNotNull<T>(value: T | null): value is T {
	return value !== null;
}

export function isNull(value: unknown): value is null {
	return value === null;
}

export function isValue<T>(value: T | undefined | null): value is T {
	return isNotNull(value) && isDefined(value);
}

export function isBoolean(value: unknown): value is boolean {
	return typeof value === 'boolean';
}

export function isNumber(value: unknown): value is number {
	return typeof value === 'number';
}

export function isArray(value: unknown): value is unknown[] {
	return isNotNull(value) && isDefined(value) && Array.isArray(value);
}

export function isRecord(value: unknown): value is Record<string, unknown> {
	return isNotNull(value) && typeof value === 'object' && !isArray(value);
}

export function isString(value: unknown): value is string {
	return typeof value === 'string';
}

export function isStringType<T extends string>(value: unknown, type: T): value is T {
	return value === type;
}

export function createIsStringTypeGuard<T extends string>(type: T): (v: unknown) => v is T {
	return v => isStringType(v, type);
}

export function createTypedArrayGuard<T>(guard: (v: unknown) => v is T): (v: unknown) => v is T[] {
	return v => isTypedArray(v, guard);
}

export function isTypedArray<T>(value: unknown, guard: (v: unknown) => v is T): value is T[] {
	if (isArray(value)) {
		if (value.length === 0) {
			return true;
		}
		return value.find(e => !guard(e)) === undefined;
	}
	return false;
}

export class PropertyCheckError extends Error {
	readonly property: string;
	readonly record: Record<string, unknown>;

	constructor(message: string, property: string, record: Record<string, unknown>) {
		super(message);
		this.property = property;
		this.record = record;
	}
}

export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T): T;
export function propValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'optional',
): T | undefined;
export function propValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'null',
): T | null;
export function propValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'optional_null',
): T | null | undefined;
export function propValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow?: 'optional' | 'null' | 'optional_null',
): T | null | undefined {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (guard(v)) {
		return v;
	}

	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T): T[];
export function propListValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'optional',
): T[] | undefined;
export function propListValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'null',
): T[] | null;
export function propListValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow: 'optional_null',
): T[] | undefined | null;
export function propListValue<T>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	allow?: 'optional' | 'null' | 'optional_null',
): T[] | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow == 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (isTypedArray(v, guard)) {
		return v;
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propMappedValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
): U;
export function propMappedValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow: 'optional',
): U | undefined;
export function propMappedValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow: 'null',
): U | null;
export function propMappedValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow: 'optional_null',
): U | undefined | null;
export function propMappedValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow?: 'optional' | 'null' | 'optional_null',
): U | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (guard(v)) {
		return map(v);
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propMappedListValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow?: 'optional' | 'null' | 'optional_null',
): U[];
export function propMappedListValue<T, U>(
	name: string,
	record: Record<string, unknown>,
	guard: (v: unknown) => v is T,
	map: (v: T) => U,
	allow?: 'optional' | 'null' | 'optional_null',
): U[] | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (isTypedArray(v, guard)) {
		return v.map(map);
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function checkProp<T, K extends string>(
	value: Record<string, unknown>,
	property: K,
	typeCheck: (value: unknown) => value is T,
	valueCheck?: (value: T) => boolean,
): value is Record<K, T> {
	if (property in value) {
		const v = value[property];
		return v !== undefined && typeCheck(v) && (valueCheck === undefined || valueCheck(v));
	}
	return false;
}

export function checkOptProp<T, K extends string>(
	value: Record<string, unknown>,
	property: K,
	typeCheck: (value: unknown) => value is T,
	valueCheck?: (value: T) => boolean,
): value is Record<K, T | undefined> {
	if (!(property in value) || value[property] === undefined) {
		return true;
	}
	return checkProp(value, property, typeCheck, valueCheck);
}

function checkListProp<T, K extends string>(
	value: Record<string, unknown>,
	property: K,
	typeCheck: (value: unknown) => value is T,
	valueCheck?: (value: T) => boolean,
): value is Record<K, T[]> {
	return checkProp(
		value,
		property,
		isArray,
		arr =>
			arr.find(v => {
				if (typeCheck(v)) {
					if (valueCheck === undefined) {
						return false;
					} else {
						return !valueCheck(v);
					}
				} else {
					return true;
				}
			}) === undefined,
	);
}

export type Replace = { '@type': 'replace' };
export type Merge = { '@type': 'merge' };

export function isReplace(value: unknown): value is Replace {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'replace')
	);
}

export function isMerge(value: unknown): value is Merge {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'merge')
	);
}

export type ListReplace<T> = {
	'@type': 'replace';
	readonly elements: readonly T[];
};

export type ListMergeAddRemove<A, R> = {
	'@type': 'merge';
	readonly additions: readonly A[];
	readonly removals: readonly R[];
};

export type ListMergeAddUpdateRemove<A, U, R> = {
	'@type': 'merge';
	readonly additions: readonly A[];
	readonly updates: readonly U[];
	readonly removals: readonly R[];
};

export function createReplaceAddRemoveGuard<T>(guard: Guard<T>): Guard<ListReplace<T> | ListMergeAddRemove<T, T>> {
	return v => isListReplace(v, guard) || isListMergeAddRemove(v, guard, guard);
}

export function createReplaceAddUpdateRemoveGuard<A, U, R>(
	guardReplaceAdd: Guard<A>,
	guardUpdate: Guard<U>,
	guardRemove: Guard<R>,
): Guard<ListReplace<A> | ListMergeAddUpdateRemove<A, U, R>> {
	return v =>
		isListReplace(v, guardReplaceAdd) || isListMergeAddUpdateRemove(v, guardReplaceAdd, guardUpdate, guardRemove);
}

export function createListReplaceGuard<T>(guard: Guard<T>): Guard<ListReplace<T>> {
	return v => isListReplace(v, guard);
}

export function isListReplace<T>(value: unknown, typeCheck: Guard<T>): value is ListReplace<T> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'replace') &&
		checkListProp(value, 'elements', typeCheck)
	);
}

export function createListMergeAddRemoveGuard<A, R>(
	addGuard: Guard<A>,
	removeGuard: Guard<R>,
): Guard<ListMergeAddRemove<A, R>> {
	return v => isListMergeAddRemove(v, addGuard, removeGuard);
}

export function isListMergeAddRemove<A, R>(
	value: unknown,
	addTypeCheck: Guard<A>,
	removeTypeCheck: Guard<R>,
): value is ListMergeAddRemove<A, R> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'merge') &&
		checkListProp(value, 'additions', addTypeCheck) &&
		checkListProp(value, 'removals', removeTypeCheck)
	);
}

export function createListMergeAddUpdateRemoveGuard<A, U, R>(
	addGuard: Guard<A>,
	updateGuard: Guard<U>,
	removeGuard: Guard<R>,
): Guard<ListMergeAddUpdateRemove<A, U, R>> {
	return v => isListMergeAddUpdateRemove(v, addGuard, updateGuard, removeGuard);
}

export function isListMergeAddUpdateRemove<A, U, R>(
	value: unknown,
	addTypeCheck: Guard<A>,
	updateTypeCheck: Guard<U>,
	removeTypeCheck: Guard<R>,
): value is ListMergeAddUpdateRemove<A, U, R> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'merge') &&
		checkListProp(value, 'additions', addTypeCheck) &&
		checkListProp(value, 'updates', updateTypeCheck) &&
		checkListProp(value, 'removals', removeTypeCheck)
	);
}

export function ListReplaceFromJSON<T, U>(
	value: Record<string, unknown>,
	typeGuard: (v: unknown) => v is U,
	map: (v: U) => T,
): ListReplace<T> {
	const elements = propMappedListValue('elements', value, typeGuard, map);
	return {
		'@type': 'replace',
		elements,
	};
}

export function ListReplaceToJSON<T>(value: ListReplace<T>, map: (value: T) => Record<string, unknown>) {
	const elements = value.elements.map(map);
	return {
		'@type': 'replace',
		elements,
	};
}

export function ListMergeAddRemoveFromJSON<A, X, R, Y>(
	value: Record<string, unknown>,
	addTypeGuard: (v: unknown) => v is X,
	addMap: (v: X) => A,
	removeTypeGuard: (v: unknown) => v is Y,
	removeMap: (v: Y) => R,
): ListMergeAddRemove<A, R> {
	const additions = propMappedListValue('additions', value, addTypeGuard, addMap);
	const removals = propMappedListValue('removals', value, removeTypeGuard, removeMap);
	return {
		'@type': 'merge',
		additions,
		removals,
	};
}

export function ListMergeAddRemoveToJSON<A, R>(
	value: ListMergeAddRemove<A, R>,
	addMap: (value: A) => unknown,
	removeMap: (value: R) => unknown,
) {
	const additions = value.additions.map(addMap);
	const removals = value.removals.map(removeMap);
	return {
		'@type': 'merge',
		additions,
		removals,
	};
}

export function ListMergeAddUpdateRemoveFromJSON<A, X, U, Y, R, Z>(
	value: Record<string, unknown>,
	addTypeGuard: (v: unknown) => v is X,
	addMap: (v: X) => A,
	updateTypeGuard: (v: unknown) => v is Y,
	updateMap: (v: Y) => U,
	removeTypeGuard: (v: unknown) => v is Z,
	removeMap: (v: Z) => R,
): ListMergeAddUpdateRemove<A, U, R> {
	const additions = propMappedListValue('additions', value, addTypeGuard, addMap);
	const updates = propMappedListValue('updates', value, updateTypeGuard, updateMap);
	const removals = propMappedListValue('removals', value, removeTypeGuard, removeMap);
	return {
		'@type': 'merge',
		additions,
		updates,
		removals,
	};
}

export function ListMergeAddUpdateRemoveToJSON<A, U, R>(
	value: ListMergeAddUpdateRemove<A, U, R>,
	addMap: (value: A) => unknown,
	updateMap: (value: U) => unknown,
	removeMap: (value: R) => unknown,
): Record<string, unknown> {
	const additions = value.additions.map(addMap);
	const updates = value.updates.map(updateMap);
	const removals = value.removals.map(removeMap);
	return {
		'@type': 'merge',
		additions,
		updates,
		removals,
	};
}

export function ReplaceOrMergeFromJSON<S, P>(
	value: Record<string, unknown>,
	replaceMapper: (value: Record<string, unknown>) => S,
	mergeMapper: (value: Record<string, unknown>) => P,
): (S & Replace) | (P & Merge) {
	if (value['@type'] === 'replace') {
		return { ...replaceMapper(value), '@type': 'replace' };
	} else if (value['@type'] === 'merge') {
		return { ...mergeMapper(value), '@type': 'merge' };
	}
	throw new Error(`Unsupported type '${String(value['@type'])}.'`);
}

export function ReplaceOrMergeToJSON<S, P>(
	value: (S & Replace) | (P & Merge),
	replaceMapper: (v: S) => Record<string, unknown>,
	mergeMapper: (v: P) => Record<string, unknown>,
): Record<string, unknown> {
	if (isReplace(value)) {
		return { ...replaceMapper(value), '@type': 'replace' };
	}
	return { ...mergeMapper(value), '@type': 'merge' };
}

export function createListReplaceToJSON<T>(
	mapper: (v: T) => Record<string, unknown>,
): (v: ListReplace<T>) => Record<string, unknown> {
	return v => ListReplaceToJSON(v, mapper);
}

// We need X because Typescript is not able to deduct the type correctly and would require a local variable
// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
export function createListMergeUpdateRemoveToJSON<A, U, R, X extends ListMergeAddUpdateRemove<A, U, R>>(
	addMapper: (v: A) => Record<string, unknown>,
	updateMapper: (v: U) => Record<string, unknown>,
	removeMapper: (v: R) => unknown,
): (v: X) => Record<string, unknown> {
	return v => ListMergeAddUpdateRemoveToJSON(v, addMapper, updateMapper, removeMapper);
}

export function noopMap<T>(v: T): T {
	return v;
}

type JsonValue =
	| undefined //
	| null
	| string
	| number
	| boolean
	| JsonObject
	| JsonArray;

type JsonObject = {
	[x: string]: JsonValue;
};

type JsonArray = JsonValue[];