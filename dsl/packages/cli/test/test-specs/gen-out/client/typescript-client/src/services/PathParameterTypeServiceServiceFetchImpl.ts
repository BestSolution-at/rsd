// Generated by RSD - Do not modify
import { decodeResponse, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createPathParameterTypeServiceService(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService {
	return {
		simpleBooleanPathParam: fnSimpleBooleanPathParam(props),
		simpleShortPathParam: fnSimpleShortPathParam(props),
		simpleIntPathParam: fnSimpleIntPathParam(props),
		simpleLongPathParam: fnSimpleLongPathParam(props),
		simpleFloatPathParam: fnSimpleFloatPathParam(props),
		simpleDoublePathParam: fnSimpleDoublePathParam(props),
		simpleStringPathParam: fnSimpleStringPathParam(props),
		simpleLocalDatePathParam: fnSimpleLocalDatePathParam(props),
		simpleLocalDateTimePathParam: fnSimpleLocalDateTimePathParam(props),
		simpleZonedDateTimePathParam: fnSimpleZonedDateTimePathParam(props),
		simpleScalarPathParam: fnSimpleScalarPathParam(props),
		simpleEnumPathParam: fnSimpleEnumPathParam(props),
		multiPathParam: fnMultiPathParam(props),
	};
}
function fnSimpleBooleanPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleBooleanPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathBoolean: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/boolean/${encodeURIComponent(pathBoolean)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isBoolean)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanPathParam');
		}
	};
}

function fnSimpleShortPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleShortPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathShort: number) => {
		try {
			const $init = (await preFetch?.('simpleShortPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/short/${encodeURIComponent(pathShort)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortPathParam');
		}
	};
}

function fnSimpleIntPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleIntPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathInt: number) => {
		try {
			const $init = (await preFetch?.('simpleIntPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/int/${encodeURIComponent(pathInt)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntPathParam');
		}
	};
}

function fnSimpleLongPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleLongPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathLong: number) => {
		try {
			const $init = (await preFetch?.('simpleLongPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/long/${encodeURIComponent(pathLong)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongPathParam');
		}
	};
}

function fnSimpleFloatPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleFloatPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathFloat: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/float/${encodeURIComponent(pathFloat)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatPathParam');
		}
	};
}

function fnSimpleDoublePathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleDoublePathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathDouble: number) => {
		try {
			const $init = (await preFetch?.('simpleDoublePathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/double/${encodeURIComponent(pathDouble)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoublePathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoublePathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoublePathParam');
		}
	};
}

function fnSimpleStringPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleStringPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathString: string) => {
		try {
			const $init = (await preFetch?.('simpleStringPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/string/${encodeURIComponent(pathString)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringPathParam');
		}
	};
}

function fnSimpleLocalDatePathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleLocalDatePathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathLocalDate: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDatePathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/localdate/${encodeURIComponent(pathLocalDate)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDatePathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDatePathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDatePathParam');
		}
	};
}

function fnSimpleLocalDateTimePathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleLocalDateTimePathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathLocalDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimePathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/localdatetime/${encodeURIComponent(pathLocalDateTime)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimePathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimePathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimePathParam');
		}
	};
}

function fnSimpleZonedDateTimePathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleZonedDateTimePathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathZonedDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimePathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/zoneddatetime/${encodeURIComponent(pathZonedDateTime)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimePathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimePathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimePathParam');
		}
	};
}

function fnSimpleScalarPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleScalarPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathScalar: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/scalar/${encodeURIComponent(pathScalar)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarPathParam');
		}
	};
}

function fnSimpleEnumPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['simpleEnumPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (pathEnum: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/enum/${encodeURIComponent(pathEnum)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isSampleEnum)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumPathParam');
		}
	};
}

function fnMultiPathParam(props: ServiceProps<api.service.ErrorType>): api.service.PathParameterTypeServiceService['multiPathParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string, valueB: number) => {
		try {
			const $init = (await preFetch?.('multiPathParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/pathparametertype/multipathparam/${encodeURIComponent(valueA)}/${encodeURIComponent(valueB)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiPathParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiPathParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiPathParam');
		}
	};
}

