// Generated by RSD - Do not modify
import { safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createHeaderParameterTypesService(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService {
	return {
		simpleBooleanHeaderParam: fnSimpleBooleanHeaderParam(props),
		simpleShortHeaderParam: fnSimpleShortHeaderParam(props),
		simpleIntHeaderParam: fnSimpleIntHeaderParam(props),
		simpleLongHeaderParam: fnSimpleLongHeaderParam(props),
		simpleFloatHeaderParam: fnSimpleFloatHeaderParam(props),
		simpleDoubleHeaderParam: fnSimpleDoubleHeaderParam(props),
		simpleStringHeaderParam: fnSimpleStringHeaderParam(props),
		simpleLocalDateHeaderParam: fnSimpleLocalDateHeaderParam(props),
		simpleLocalDateTimeHeaderParam: fnSimpleLocalDateTimeHeaderParam(props),
		simpleZonedDateTimeHeaderParam: fnSimpleZonedDateTimeHeaderParam(props),
		simpleScalarHeaderParam: fnSimpleScalarHeaderParam(props),
		simpleEnumHeaderParam: fnSimpleEnumHeaderParam(props),
		multiHeaderParam: fnMultiHeaderParam(props),
		recordHeaderParam: fnRecordHeaderParam(props),
	};
}
function fnSimpleBooleanHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleBooleanHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleBooleanHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isBoolean($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanHeaderParam');
		}
	};
}

function fnSimpleShortHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleShortHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number) => {
		try {
			const $init = (await preFetch?.('simpleShortHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleShortHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortHeaderParam');
		}
	};
}

function fnSimpleIntHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleIntHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number) => {
		try {
			const $init = (await preFetch?.('simpleIntHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleIntHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntHeaderParam');
		}
	};
}

function fnSimpleLongHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleLongHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number) => {
		try {
			const $init = (await preFetch?.('simpleLongHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleLongHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongHeaderParam');
		}
	};
}

function fnSimpleFloatHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleFloatHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleFloatHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatHeaderParam');
		}
	};
}

function fnSimpleDoubleHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleDoubleHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', String(headerValue));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleDoubleHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleHeaderParam');
		}
	};
}

function fnSimpleStringHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleStringHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string) => {
		try {
			const $init = (await preFetch?.('simpleStringHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleStringHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringHeaderParam');
		}
	};
}

function fnSimpleLocalDateHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleLocalDateHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleLocalDateHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateHeaderParam');
		}
	};
}

function fnSimpleLocalDateTimeHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleLocalDateTimeHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleLocalDateTimeHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeHeaderParam');
		}
	};
}

function fnSimpleZonedDateTimeHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleZonedDateTimeHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleZonedDateTimeHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeHeaderParam');
		}
	};
}

function fnSimpleScalarHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleScalarHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleScalarHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarHeaderParam');
		}
	};
}

function fnSimpleEnumHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['simpleEnumHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', headerValue);
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/simpleEnumHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.model.isSampleEnum($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumHeaderParam');
		}
	};
}

function fnMultiHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['multiHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string, valueB: number) => {
		try {
			const $init = (await preFetch?.('multiHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('valueA', valueA);
			$headers.append('valueB', String(valueB));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/multiHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if (!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiHeaderParam');
		}
	};
}

function fnRecordHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.HeaderParameterTypesService['recordHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$headers.append('headerValue', JSON.stringify(api.model.SimpleRecordToJSON(headerValue)));
			$init.headers = $headers;

			const $path = `${baseUrl}/api/headerparametertypes/recordHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isRecord($data)) {
					throw new Error('Invalid result');
				}
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('recordHeaderParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordHeaderParam');
		}
	};
}

