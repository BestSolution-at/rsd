// Generated by RSD - Do not modify
import { decodeResponse, encodeValue, encodingType, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

function isListInlineEnumHeaderParamResult(value: unknown): value is 'A' | 'B' {
	return value === 'A' || value === 'B';
}

export function createListHeaderParameterTypesService(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService {
	return {
		listBooleanHeaderParam: fnListBooleanHeaderParam(props),
		listShortHeaderParam: fnListShortHeaderParam(props),
		listIntHeaderParam: fnListIntHeaderParam(props),
		listLongHeaderParam: fnListLongHeaderParam(props),
		listFloatHeaderParam: fnListFloatHeaderParam(props),
		listDoubleHeaderParam: fnListDoubleHeaderParam(props),
		listStringHeaderParam: fnListStringHeaderParam(props),
		listLocalDateHeaderParam: fnListLocalDateHeaderParam(props),
		listLocalDateTimeHeaderParam: fnListLocalDateTimeHeaderParam(props),
		listZonedDateTimeHeaderParam: fnListZonedDateTimeHeaderParam(props),
		listScalarHeaderParam: fnListScalarHeaderParam(props),
		listEnumHeaderParam: fnListEnumHeaderParam(props),
		listInlineEnumHeaderParam: fnListInlineEnumHeaderParam(props),
		listMultiHeaderParam: fnListMultiHeaderParam(props),
		listRecordHeaderParam: fnListRecordHeaderParam(props),
	};
}
function fnListBooleanHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listBooleanHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: boolean[]) => {
		try {
			const $init = (await preFetch?.('listBooleanHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listBooleanHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isBoolean));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listBooleanHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listBooleanHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listBooleanHeaderParam');
		}
	};
}

function fnListShortHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listShortHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number[]) => {
		try {
			const $init = (await preFetch?.('listShortHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listShortHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listShortHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listShortHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listShortHeaderParam');
		}
	};
}

function fnListIntHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listIntHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number[]) => {
		try {
			const $init = (await preFetch?.('listIntHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listIntHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listIntHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listIntHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listIntHeaderParam');
		}
	};
}

function fnListLongHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listLongHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number[]) => {
		try {
			const $init = (await preFetch?.('listLongHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listLongHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLongHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLongHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLongHeaderParam');
		}
	};
}

function fnListFloatHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listFloatHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number[]) => {
		try {
			const $init = (await preFetch?.('listFloatHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listFloatHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listFloatHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listFloatHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listFloatHeaderParam');
		}
	};
}

function fnListDoubleHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listDoubleHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: number[]) => {
		try {
			const $init = (await preFetch?.('listDoubleHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', String($entry));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listDoubleHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listDoubleHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listDoubleHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listDoubleHeaderParam');
		}
	};
}

function fnListStringHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listStringHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string[]) => {
		try {
			const $init = (await preFetch?.('listStringHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listStringHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listStringHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listStringHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listStringHeaderParam');
		}
	};
}

function fnListLocalDateHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listLocalDateHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string[]) => {
		try {
			const $init = (await preFetch?.('listLocalDateHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listLocalDateHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDateHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDateHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDateHeaderParam');
		}
	};
}

function fnListLocalDateTimeHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listLocalDateTimeHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string[]) => {
		try {
			const $init = (await preFetch?.('listLocalDateTimeHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listLocalDateTimeHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDateTimeHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDateTimeHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDateTimeHeaderParam');
		}
	};
}

function fnListZonedDateTimeHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listZonedDateTimeHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string[]) => {
		try {
			const $init = (await preFetch?.('listZonedDateTimeHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listZonedDateTimeHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listZonedDateTimeHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listZonedDateTimeHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listZonedDateTimeHeaderParam');
		}
	};
}

function fnListScalarHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listScalarHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: string[]) => {
		try {
			const $init = (await preFetch?.('listScalarHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listScalarHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listScalarHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listScalarHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listScalarHeaderParam');
		}
	};
}

function fnListEnumHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listEnumHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: api.model.SampleEnum[]) => {
		try {
			const $init = (await preFetch?.('listEnumHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listEnumHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.model.isSampleEnum));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listEnumHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listEnumHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listEnumHeaderParam');
		}
	};
}

function fnListInlineEnumHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listInlineEnumHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: ('A' | 'B')[]) => {
		try {
			const $init = (await preFetch?.('listInlineEnumHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', $entry);
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listInlineEnumHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, isListInlineEnumHeaderParamResult));
				return safeExecute(api.result.OK($data), () => onSuccess?.('listInlineEnumHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listInlineEnumHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listInlineEnumHeaderParam');
		}
	};
}

function fnListMultiHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listMultiHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string[], valueB: number[], valueC: api.model.SimpleRecord[]) => {
		try {
			const $init = (await preFetch?.('listMultiHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			valueA.forEach($entry => {
				$headers.append('valueA', $entry);
			});
			valueB.forEach($entry => {
				$headers.append('valueB', String($entry));
			});
			valueC.forEach($entry => {
				$headers.append('valueC', encodeValue(encodingType(props), api.model.SimpleRecordToJSON($entry)));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listMultiHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString);
				return safeExecute(api.result.OK($data), () => onSuccess?.('listMultiHeaderParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listMultiHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listMultiHeaderParam');
		}
	};
}

function fnListRecordHeaderParam(props: ServiceProps<api.service.ErrorType>): api.service.ListHeaderParameterTypesService['listRecordHeaderParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (headerValue: api.model.SimpleRecord[]) => {
		try {
			const $init = (await preFetch?.('listRecordHeaderParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			headerValue.forEach($entry => {
				$headers.append('headerValue', encodeValue(encodingType(props), api.model.SimpleRecordToJSON($entry)));
			});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listheaderparametertypes/listRecordHeaderParam`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isRecord));
				const $result = $data.map(api.model.SimpleRecordFromJSON);
				return safeExecute(api.result.OK($result), () => onSuccess?.('listRecordHeaderParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listRecordHeaderParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listRecordHeaderParam');
		}
	};
}

