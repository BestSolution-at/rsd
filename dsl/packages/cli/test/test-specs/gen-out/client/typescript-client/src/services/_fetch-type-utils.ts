// Generated by RSD - Do not modify
import { api } from '../index.js';

export type ContentTypeEncodings = 'application/json';
export type Fetch = typeof fetch;
export type ServiceProps<T extends string = string> = {
	baseUrl: string;
	fetchAPI?: Fetch;
	lifecycleHandlers?: {
		preFetch?: (method: string) => RequestInit | Promise<RequestInit>;
		onSuccess?: (method: string, value: unknown) => void;
		onError?: (method: string, err: api.result.RSDError<T>) => void;
		onCatch?: (method: string, err: unknown) => void;
		final?: (method: string) => void;
	};
	encoding?: ContentTypeEncodings;
};

export function encodingType(props: ServiceProps<never>): ContentTypeEncodings {
	return props.encoding ?? 'application/json';
}

export function safeExecute<T>(value: T, block: () => void): T {
	try {
		block();
	} catch (e) {
		console.error('Failed running block', e);
	}

	return value;
}

export function encodeBase64(value: string): string {
	const bytes = new TextEncoder().encode(value);
	const binString = Array.from(bytes, byte => String.fromCodePoint(byte)).join('');
	return btoa(binString);
}

export function encodeAsciiString(text: string): string {
	text = text.replaceAll('\\u', '\\u005Cu'); // Escape existing \u sequences
	let b = '';
	const l = text.length;
	for (let i = 0; i < l; i++) {
		const c = text.charCodeAt(i);
		// Escape non-printable characters, comma and all non-ASCII characters
		if (c < 32 || c > 126 || c === 44) {
			b += `\\u${c.toString(16).padStart(4, '0')}`;
		} else {
			b += text.charAt(i);
		}
	}

	return b;
}

export function decodeAsciiString(text: string): string {
	return text.replace(/\\u([0-9a-fA-F]{4})/g, (_, g1) => String.fromCharCode(parseInt(String(g1), 16)));
}

export function encodeValue(_type: ContentTypeEncodings, value: unknown) {
	return encodeJsonBody(value);
}

function encodeJsonBody(body: unknown): string {
	return JSON.stringify(body);
}

export function decodeResponse<T>(response: Response, guard: (value: unknown) => value is T): Promise<T> {
	const contentType = response.headers.get('Content-Type')?.split(';')[0]?.trim();
	switch (contentType) {
		case 'application/json':
			return decodeJsonBody<T>(response, guard);
		default:
			throw new Error(`Unsupported response content type: ${String(contentType)}`);
	}
}

async function decodeJsonBody<T>(response: Response, guard: (value: unknown) => value is T): Promise<T> {
	const data = await response.json();
	if (!guard(data)) {
		throw new Error('Invalid result');
	}
	return data;
}
