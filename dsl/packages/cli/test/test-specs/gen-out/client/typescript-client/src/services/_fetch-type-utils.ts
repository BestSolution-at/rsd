// Generated by RSD - Do not modify
import { api } from '../index.js';

export type ContentTypeEncodings = 'application/json';
export type Fetch = typeof fetch;
export type ServiceProps<T extends string = string> = {
	baseUrl: string;
	fetchAPI?: Fetch;
	lifecycleHandlers?: {
		preFetch?: (method: string) => RequestInit | Promise<RequestInit>;
		onSuccess?: (method: string, value: unknown) => void;
		onError?: (method: string, err: api.result.RSDError<T>) => void;
		onCatch?: (method: string, err: unknown) => void;
		final?: (method: string) => void;
	};
	encoding?: ContentTypeEncodings;
};

export function encodingType(props: ServiceProps<never>): ContentTypeEncodings	{
	return props.encoding ?? 'application/json';
}

export function safeExecute<T>(value: T, block: () => void): T {
	try {
		block();
	} catch (e) {
		console.error('Failed running block', e);
	}

	return value;
}

export function encodeValue(_type: ContentTypeEncodings, value: unknown) {
	return encodeJsonBody(value);
}

function encodeJsonBody(body: unknown): string {
	return JSON.stringify(body);
}

export function decodeResponse<T>(response: Response, guard: (value: unknown) => value is T): Promise<T> {
	const contentType = response.headers.get('Content-Type')?.split(';')[0]?.trim();
	switch (contentType) {
		case 'application/json':
			return decodeJsonBody<T>(response, guard);
		default:
			throw new Error(`Unsupported response content type: ${String(contentType)}`);
	}
}

async function decodeJsonBody<T>(response: Response, guard: (value: unknown) => value is T): Promise<T> {
	const data = await response.json();
	if (!guard(data)) {
		throw new Error('Invalid result');
	}
	return data;
}

