// Generated by RSD - Do not modify
import { safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createBinaryTypesService(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService {
	return {
		uploadFile: fnUploadFile(props),
		uploadBlob: fnUploadBlob(props),
		downloadFile: fnDownloadFile(props),
		downloadBlob: fnDownloadBlob(props),
	};
}
function fnUploadFile(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFile'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: File) => {
		try {
			const $init = (await preFetch?.('uploadFile')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFile`;
			const $body = new FormData();
			$body.append('data', data);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFile', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFile', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFile');
		}
	};
}

function fnUploadBlob(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlob'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: Blob) => {
		try {
			const $init = (await preFetch?.('uploadBlob')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlob`;
			const $body = new FormData();
			$body.append('data', data);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await $response.json();
				if (!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlob', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlob', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlob');
		}
	};
}

function fnDownloadFile(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['downloadFile'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('downloadFile')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/downloadFile`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.blob();
				let fileName = 'unknown';
				const dispoHeader = $response.headers.get('Content-Disposition');
				if (dispoHeader?.includes('filename=')) {
					const fileNameWithQuotes = dispoHeader.substring(dispoHeader.indexOf('filename=') + 'filename='.length);
					fileName = fileNameWithQuotes.substring(1, fileNameWithQuotes.length - 1);
				}
				const $result = new File([$data], fileName, { type: $data.type });
				return safeExecute(api.result.OK($result), () => onSuccess?.('downloadFile', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('downloadFile', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('downloadFile');
		}
	};
}

function fnDownloadBlob(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['downloadBlob'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('downloadBlob')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/downloadBlob`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.blob();
				const $result = $data;
				return safeExecute(api.result.OK($result), () => onSuccess?.('downloadBlob', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('downloadBlob', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('downloadBlob');
		}
	};
}

