// Generated by RSD - Do not modify
import { decodeResponse, encodeValue, encodingType, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createBinaryTypesService(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService {
	return {
		uploadFile: fnUploadFile(props),
		uploadFileOpt: fnUploadFileOpt(props),
		uploadFileNil: fnUploadFileNil(props),
		uploadFileOptNil: fnUploadFileOptNil(props),
		uploadBlob: fnUploadBlob(props),
		uploadBlobOpt: fnUploadBlobOpt(props),
		uploadBlobNil: fnUploadBlobNil(props),
		uploadBlobOptNil: fnUploadBlobOptNil(props),
		uploadFileList: fnUploadFileList(props),
		uploadFileListOpt: fnUploadFileListOpt(props),
		uploadFileListNil: fnUploadFileListNil(props),
		uploadFileListOptNil: fnUploadFileListOptNil(props),
		uploadBlobList: fnUploadBlobList(props),
		uploadBlobListOpt: fnUploadBlobListOpt(props),
		uploadBlobListNil: fnUploadBlobListNil(props),
		uploadBlobListOptNil: fnUploadBlobListOptNil(props),
		uploadMixed: fnUploadMixed(props),
		uploadMixedOpt: fnUploadMixedOpt(props),
		uploadMixedNil: fnUploadMixedNil(props),
		uploadMixedOptNil: fnUploadMixedOptNil(props),
		downloadFile: fnDownloadFile(props),
		downloadBlob: fnDownloadBlob(props),
	};
}
function fnUploadFile(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFile'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: File) => {
		try {
			const $init = (await preFetch?.('uploadFile')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFile`;
			const $body = new FormData();
			$body.append('data', data);
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFile', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFile', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFile');
		}
	};
}

function fnUploadFileOpt(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: File) => {
		try {
			const $init = (await preFetch?.('uploadFileOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileOpt`;
			const $body = new FormData();
			if (data !== undefined) {
				$body.append('data', data);
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileOpt');
		}
	};
}

function fnUploadFileNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: File | null) => {
		try {
			const $init = (await preFetch?.('uploadFileNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileNil`;
			const $body = new FormData();
			if (data !== null) {
				$body.append('data', data);
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileNil');
		}
	};
}

function fnUploadFileOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: File | null) => {
		try {
			const $init = (await preFetch?.('uploadFileOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileOptNil`;
			const $body = new FormData();
			if (data !== undefined && data !== null) {
				$body.append('data', data);
			} else if(data === null) {
				$body.append('_rsdNull-data', 'true');
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileOptNil');
		}
	};
}

function fnUploadBlob(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlob'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: Blob) => {
		try {
			const $init = (await preFetch?.('uploadBlob')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlob`;
			const $body = new FormData();
			$body.append('data', data);
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlob', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlob', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlob');
		}
	};
}

function fnUploadBlobOpt(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: Blob) => {
		try {
			const $init = (await preFetch?.('uploadBlobOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobOpt`;
			const $body = new FormData();
			if (data !== undefined) {
				$body.append('data', data);
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobOpt');
		}
	};
}

function fnUploadBlobNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: Blob | null) => {
		try {
			const $init = (await preFetch?.('uploadBlobNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobNil`;
			const $body = new FormData();
			if (data !== null) {
				$body.append('data', data);
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobNil');
		}
	};
}

function fnUploadBlobOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: Blob | null) => {
		try {
			const $init = (await preFetch?.('uploadBlobOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobOptNil`;
			const $body = new FormData();
			if (data !== undefined && data !== null) {
				$body.append('data', data);
			} else if(data === null) {
				$body.append('_rsdNull-data', 'true');
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 201) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobOptNil');
		}
	};
}

function fnUploadFileList(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileList'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: File[]) => {
		try {
			const $init = (await preFetch?.('uploadFileList')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileList`;
			const $body = new FormData();
			data.forEach($entry => {
				$body.append('data', $entry);
			});
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileList', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileList', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileList');
		}
	};
}

function fnUploadFileListOpt(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileListOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: File[]) => {
		try {
			const $init = (await preFetch?.('uploadFileListOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileListOpt`;
			const $body = new FormData();
			if (data !== undefined) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileListOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileListOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileListOpt');
		}
	};
}

function fnUploadFileListNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileListNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: File[] | null) => {
		try {
			const $init = (await preFetch?.('uploadFileListNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileListNil`;
			const $body = new FormData();
			if (data !== null) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileListNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileListNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileListNil');
		}
	};
}

function fnUploadFileListOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadFileListOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: File[] | null) => {
		try {
			const $init = (await preFetch?.('uploadFileListOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadFileListOptNil`;
			const $body = new FormData();
			if (data !== undefined && data !== null) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			} else if(data === null) {
				$body.append('_rsdNull-data', 'true');
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadFileListOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadFileListOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadFileListOptNil');
		}
	};
}

function fnUploadBlobList(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobList'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: Blob[]) => {
		try {
			const $init = (await preFetch?.('uploadBlobList')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobList`;
			const $body = new FormData();
			data.forEach($entry => {
				$body.append('data', $entry);
			});
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobList', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobList', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobList');
		}
	};
}

function fnUploadBlobListOpt(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobListOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: Blob[]) => {
		try {
			const $init = (await preFetch?.('uploadBlobListOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobListOpt`;
			const $body = new FormData();
			if (data !== undefined) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobListOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobListOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobListOpt');
		}
	};
}

function fnUploadBlobListNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobListNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data: Blob[] | null) => {
		try {
			const $init = (await preFetch?.('uploadBlobListNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobListNil`;
			const $body = new FormData();
			if (data !== null) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobListNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobListNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobListNil');
		}
	};
}

function fnUploadBlobListOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadBlobListOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (data?: Blob[] | null) => {
		try {
			const $init = (await preFetch?.('uploadBlobListOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadBlobListOptNil`;
			const $body = new FormData();
			if (data !== undefined && data !== null) {
				data.forEach($entry => {
					$body.append('data', $entry);
				});
			} else if(data === null) {
				$body.append('_rsdNull-data', 'true');
			}
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber);
				return safeExecute(api.result.OK($data), () => onSuccess?.('uploadBlobListOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadBlobListOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadBlobListOptNil');
		}
	};
}

function fnUploadMixed(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadMixed'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (text: string, number: number, rec: api.model.SimpleRecord, textList: string[], numberList: number[], recList: api.model.SimpleRecord[], dataFile: File, dataBlob: Blob) => {
		try {
			const $init = (await preFetch?.('uploadMixed')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadMixed`;
			const $body = new FormData();
			$body.append('dataFile', dataFile);
			$body.append('dataBlob', dataBlob);
			const $jsonPayload = {
				text,
				number,
				rec: api.model.SimpleRecordToJSON(rec),
				textList,
				numberList,
				recList: recList.map(api.model.SimpleRecordToJSON),
			};
			$body.append('_rsdPayload', new Blob([encodeValue(encodingType(props), $jsonPayload)], { type: encodingType(props) }));
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord);
				const $result = api.model.UploadMixedResultFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('uploadMixed', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadMixed', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadMixed');
		}
	};
}

function fnUploadMixedOpt(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadMixedOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (text?: string, number?: number, rec?: api.model.SimpleRecord, textList?: string[], numberList?: number[], recList?: api.model.SimpleRecord[], dataFile?: File, dataBlob?: Blob) => {
		try {
			const $init = (await preFetch?.('uploadMixedOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadMixedOpt`;
			const $body = new FormData();
			if (dataFile !== undefined) {
				$body.append('dataFile', dataFile);
			}
			if (dataBlob !== undefined) {
				$body.append('dataBlob', dataBlob);
			}
			const $jsonPayload = {
				text,
				number,
				rec: rec ? api.model.SimpleRecordToJSON(rec) : rec,
				textList,
				numberList,
				recList: recList ? recList.map(api.model.SimpleRecordToJSON) : recList,
			};
			$body.append('_rsdPayload', new Blob([encodeValue(encodingType(props), $jsonPayload)], { type: encodingType(props) }));
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord);
				const $result = api.model.UploadMixedResultFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('uploadMixedOpt', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadMixedOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadMixedOpt');
		}
	};
}

function fnUploadMixedNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadMixedNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (text: string | null, number: number | null, rec: api.model.SimpleRecord | null, textList: string[] | null, numberList: number[] | null, recList: api.model.SimpleRecord[] | null, dataFile: File | null, dataBlob: Blob | null) => {
		try {
			const $init = (await preFetch?.('uploadMixedNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadMixedNil`;
			const $body = new FormData();
			if (dataFile !== null) {
				$body.append('dataFile', dataFile);
			}
			if (dataBlob !== null) {
				$body.append('dataBlob', dataBlob);
			}
			const $jsonPayload = {
				text,
				number,
				rec: rec ? api.model.SimpleRecordToJSON(rec) : rec,
				textList,
				numberList,
				recList: recList ? recList.map(api.model.SimpleRecordToJSON) : recList,
			};
			$body.append('_rsdPayload', new Blob([encodeValue(encodingType(props), $jsonPayload)], { type: encodingType(props) }));
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord);
				const $result = api.model.UploadMixedResultFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('uploadMixedNil', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadMixedNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadMixedNil');
		}
	};
}

function fnUploadMixedOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['uploadMixedOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (text?: string | null, number?: number | null, rec?: api.model.SimpleRecord | null, textList?: string[] | null, numberList?: number[] | null, recList?: api.model.SimpleRecord[] | null, dataFile?: File | null, dataBlob?: Blob | null) => {
		try {
			const $init = (await preFetch?.('uploadMixedOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/uploadMixedOptNil`;
			const $body = new FormData();
			if (dataFile !== undefined && dataFile !== null) {
				$body.append('dataFile', dataFile);
			} else if(dataFile === null) {
				$body.append('_rsdNull-dataFile', 'true');
			}
			if (dataBlob !== undefined && dataBlob !== null) {
				$body.append('dataBlob', dataBlob);
			} else if(dataBlob === null) {
				$body.append('_rsdNull-dataBlob', 'true');
			}
			const $jsonPayload = {
				text,
				number,
				rec: rec ? api.model.SimpleRecordToJSON(rec) : rec,
				textList,
				numberList,
				recList: recList ? recList.map(api.model.SimpleRecordToJSON) : recList,
			};
			$body.append('_rsdPayload', new Blob([encodeValue(encodingType(props), $jsonPayload)], { type: encodingType(props) }));
			if ($body.values().next().done) {
				$body.append('_rsdQuarkusBugDummy', '');
			}
			const $response = await fetchAPI($path, { ...$init, method: 'PUT', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord);
				const $result = api.model.UploadMixedResultFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('uploadMixedOptNil', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('uploadMixedOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('uploadMixedOptNil');
		}
	};
}

function fnDownloadFile(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['downloadFile'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('downloadFile')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/downloadFile`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.blob();
				let fileName = 'unknown';
				const dispoHeader = $response.headers.get('Content-Disposition');
				if (dispoHeader?.includes('filename=')) {
					const fileNameWithQuotes = dispoHeader.substring(dispoHeader.indexOf('filename=') + 'filename='.length);
					fileName = fileNameWithQuotes.substring(1, fileNameWithQuotes.length - 1);
				}
				const $result = new File([$data], fileName, { type: $data.type });
				return safeExecute(api.result.OK($result), () => onSuccess?.('downloadFile', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('downloadFile', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('downloadFile');
		}
	};
}

function fnDownloadBlob(props: ServiceProps<api.service.ErrorType>): api.service.BinaryTypesService['downloadBlob'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('downloadBlob')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/binarytypes/downloadBlob`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await $response.blob();
				const $result = $data;
				return safeExecute(api.result.OK($result), () => onSuccess?.('downloadBlob', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('downloadBlob', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('downloadBlob');
		}
	};
}

