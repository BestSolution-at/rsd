// Generated by RSD - Do not modify
import { safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

function isSimpleInlineEnumBodyParamResult(value: unknown): value is 'A' | 'B' {
	return value === 'A' || value === 'B';
}

export function createBodyParameterTypesService(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService {
	return {
		simpleBooleanBodyParam: fnSimpleBooleanBodyParam(props),
		simpleShortBodyParam: fnSimpleShortBodyParam(props),
		simpleIntBodyParam: fnSimpleIntBodyParam(props),
		simpleLongBodyParam: fnSimpleLongBodyParam(props),
		simpleFloatBodyParam: fnSimpleFloatBodyParam(props),
		simpleDoubleBodyParam: fnSimpleDoubleBodyParam(props),
		simpleStringBodyParam: fnSimpleStringBodyParam(props),
		simpleLocalDateBodyParam: fnSimpleLocalDateBodyParam(props),
		simpleLocalDateTimeBodyParam: fnSimpleLocalDateTimeBodyParam(props),
		simpleZonedDateTimeBodyParam: fnSimpleZonedDateTimeBodyParam(props),
		simpleScalarBodyParam: fnSimpleScalarBodyParam(props),
		simpleEnumBodyParam: fnSimpleEnumBodyParam(props),
		simpleInlineEnumBodyParam: fnSimpleInlineEnumBodyParam(props),
		multiBodyParam: fnMultiBodyParam(props),
		recordBodyParam: fnRecordBodyParam(props),
	};
}
function fnSimpleBooleanBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleBooleanBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyBoolean: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleBooleanBodyParam`;
			const $body = String(bodyBoolean);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isBoolean($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanBodyParam');
		}
	};
}

function fnSimpleShortBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleShortBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyShort: number) => {
		try {
			const $init = (await preFetch?.('simpleShortBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleShortBodyParam`;
			const $body = String(bodyShort);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortBodyParam');
		}
	};
}

function fnSimpleIntBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleIntBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyInt: number) => {
		try {
			const $init = (await preFetch?.('simpleIntBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleIntBodyParam`;
			const $body = String(bodyInt);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntBodyParam');
		}
	};
}

function fnSimpleLongBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLongBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLong: number) => {
		try {
			const $init = (await preFetch?.('simpleLongBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLongBodyParam`;
			const $body = String(bodyLong);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongBodyParam');
		}
	};
}

function fnSimpleFloatBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleFloatBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyFloat: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleFloatBodyParam`;
			const $body = String(bodyFloat);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatBodyParam');
		}
	};
}

function fnSimpleDoubleBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleDoubleBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyDouble: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleDoubleBodyParam`;
			const $body = String(bodyDouble);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isNumber($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleBodyParam');
		}
	};
}

function fnSimpleStringBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleStringBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyString: string) => {
		try {
			const $init = (await preFetch?.('simpleStringBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleStringBodyParam`;
			const $body = `"${bodyString}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringBodyParam');
		}
	};
}

function fnSimpleLocalDateBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDate: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateBodyParam`;
			const $body = `"${bodyLocalDate}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateBodyParam');
		}
	};
}

function fnSimpleLocalDateTimeBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateTimeBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateTimeBodyParam`;
			const $body = `"${bodyLocalDateTime}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeBodyParam');
		}
	};
}

function fnSimpleZonedDateTimeBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleZonedDateTimeBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyZonedDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleZonedDateTimeBodyParam`;
			const $body = `"${bodyZonedDateTime}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeBodyParam');
		}
	};
}

function fnSimpleScalarBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleScalarBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyScalar: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleScalarBodyParam`;
			const $body = `"${bodyScalar}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarBodyParam');
		}
	};
}

function fnSimpleEnumBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleEnumBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleEnumBodyParam`;
			const $body = `"${bodyEnum}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.model.isSampleEnum($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumBodyParam');
		}
	};
}

function fnSimpleInlineEnumBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleInlineEnumBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: 'A' | 'B') => {
		try {
			const $init = (await preFetch?.('simpleInlineEnumBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleInlineEnumBodyParam`;
			const $body = `"${bodyEnum}"`;
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!isSimpleInlineEnumBodyParamResult($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleInlineEnumBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleInlineEnumBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleInlineEnumBodyParam');
		}
	};
}

function fnMultiBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string, valueB: number) => {
		try {
			const $init = (await preFetch?.('multiBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParam`;
			const $body = JSON.stringify({
				valueA,
				valueB,
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isString($data)) {
					throw new Error('Invalid result');
				}
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParam');
		}
	};
}

function fnRecordBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['recordBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/recordBodyParam`;
			const $body = JSON.stringify(api.model.SimpleRecordToJSON(bodyRecord));
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isRecord($data)) {
					throw new Error('Invalid result');
				}
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('recordBodyParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordBodyParam');
		}
	};
}

