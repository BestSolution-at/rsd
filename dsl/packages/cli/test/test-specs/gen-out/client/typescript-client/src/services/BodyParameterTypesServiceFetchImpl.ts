// Generated by RSD - Do not modify
import { decodeResponse, encodeValue, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

function isSimpleInlineEnumBodyParamResult(value: unknown): value is 'A' | 'B' {
	return value === 'A' || value === 'B';
}

export function createBodyParameterTypesService(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService {
	return {
		simpleBooleanBodyParam: fnSimpleBooleanBodyParam(props),
		simpleBooleanBodyParamOpt: fnSimpleBooleanBodyParamOpt(props),
		simpleBooleanBodyParamNil: fnSimpleBooleanBodyParamNil(props),
		simpleBooleanBodyParamOptNil: fnSimpleBooleanBodyParamOptNil(props),
		simpleShortBodyParam: fnSimpleShortBodyParam(props),
		simpleShortBodyParamOpt: fnSimpleShortBodyParamOpt(props),
		simpleShortBodyParamNil: fnSimpleShortBodyParamNil(props),
		simpleShortBodyParamOptNil: fnSimpleShortBodyParamOptNil(props),
		simpleIntBodyParam: fnSimpleIntBodyParam(props),
		simpleIntBodyParamOpt: fnSimpleIntBodyParamOpt(props),
		simpleIntBodyParamNil: fnSimpleIntBodyParamNil(props),
		simpleIntBodyParamOptNil: fnSimpleIntBodyParamOptNil(props),
		simpleLongBodyParam: fnSimpleLongBodyParam(props),
		simpleLongBodyParamOpt: fnSimpleLongBodyParamOpt(props),
		simpleLongBodyParamNil: fnSimpleLongBodyParamNil(props),
		simpleLongBodyParamOptNil: fnSimpleLongBodyParamOptNil(props),
		simpleFloatBodyParam: fnSimpleFloatBodyParam(props),
		simpleFloatBodyParamOpt: fnSimpleFloatBodyParamOpt(props),
		simpleFloatBodyParamNil: fnSimpleFloatBodyParamNil(props),
		simpleFloatBodyParamOptNil: fnSimpleFloatBodyParamOptNil(props),
		simpleDoubleBodyParam: fnSimpleDoubleBodyParam(props),
		simpleDoubleBodyParamOpt: fnSimpleDoubleBodyParamOpt(props),
		simpleDoubleBodyParamNil: fnSimpleDoubleBodyParamNil(props),
		simpleDoubleBodyParamOptNil: fnSimpleDoubleBodyParamOptNil(props),
		simpleStringBodyParam: fnSimpleStringBodyParam(props),
		simpleStringBodyParamOpt: fnSimpleStringBodyParamOpt(props),
		simpleStringBodyParamNil: fnSimpleStringBodyParamNil(props),
		simpleStringBodyParamOptNil: fnSimpleStringBodyParamOptNil(props),
		simpleLocalDateBodyParam: fnSimpleLocalDateBodyParam(props),
		simpleLocalDateBodyParamOpt: fnSimpleLocalDateBodyParamOpt(props),
		simpleLocalDateBodyParamNil: fnSimpleLocalDateBodyParamNil(props),
		simpleLocalDateBodyParamOptNil: fnSimpleLocalDateBodyParamOptNil(props),
		simpleLocalDateTimeBodyParam: fnSimpleLocalDateTimeBodyParam(props),
		simpleLocalDateTimeBodyParamOpt: fnSimpleLocalDateTimeBodyParamOpt(props),
		simpleLocalDateTimeBodyParamNil: fnSimpleLocalDateTimeBodyParamNil(props),
		simpleLocalDateTimeBodyParamOptNil: fnSimpleLocalDateTimeBodyParamOptNil(props),
		simpleZonedDateTimeBodyParam: fnSimpleZonedDateTimeBodyParam(props),
		simpleZonedDateTimeBodyParamOpt: fnSimpleZonedDateTimeBodyParamOpt(props),
		simpleZonedDateTimeBodyParamNil: fnSimpleZonedDateTimeBodyParamNil(props),
		simpleZonedDateTimeBodyParamOptNil: fnSimpleZonedDateTimeBodyParamOptNil(props),
		simpleScalarBodyParam: fnSimpleScalarBodyParam(props),
		simpleScalarBodyParamOpt: fnSimpleScalarBodyParamOpt(props),
		simpleScalarBodyParamNil: fnSimpleScalarBodyParamNil(props),
		simpleScalarBodyParamOptNil: fnSimpleScalarBodyParamOptNil(props),
		simpleEnumBodyParam: fnSimpleEnumBodyParam(props),
		simpleEnumBodyParamOpt: fnSimpleEnumBodyParamOpt(props),
		simpleEnumBodyParamNil: fnSimpleEnumBodyParamNil(props),
		simpleEnumBodyParamOptNil: fnSimpleEnumBodyParamOptNil(props),
		simpleInlineEnumBodyParam: fnSimpleInlineEnumBodyParam(props),
		simpleInlineEnumBodyParamOpt: fnSimpleInlineEnumBodyParamOpt(props),
		simpleInlineEnumBodyParamNil: fnSimpleInlineEnumBodyParamNil(props),
		simpleInlineEnumBodyParamOptNil: fnSimpleInlineEnumBodyParamOptNil(props),
		multiBodyParam: fnMultiBodyParam(props),
		multiBodyParamOpt: fnMultiBodyParamOpt(props),
		multiBodyParamNil: fnMultiBodyParamNil(props),
		multiBodyParamOptNil: fnMultiBodyParamOptNil(props),
		multiBodyParamFirst: fnMultiBodyParamFirst(props),
		recordBodyParam: fnRecordBodyParam(props),
		recordBodyParamOpt: fnRecordBodyParamOpt(props),
		recordBodyParamNil: fnRecordBodyParamNil(props),
		recordBodyParamOptNil: fnRecordBodyParamOptNil(props),
		unionBodyParam: fnUnionBodyParam(props),
		unionBodyParamOpt: fnUnionBodyParamOpt(props),
		unionBodyParamNil: fnUnionBodyParamNil(props),
		unionBodyParamOptNil: fnUnionBodyParamOptNil(props),
		patchableRecordBodyParam: fnPatchableRecordBodyParam(props),
		patchableRecordBodyParamOpt: fnPatchableRecordBodyParamOpt(props),
		patchableRecordBodyParamNil: fnPatchableRecordBodyParamNil(props),
		patchableRecordBodyParamOptNil: fnPatchableRecordBodyParamOptNil(props),
	};
}
function fnSimpleBooleanBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleBooleanBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyBoolean: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleBooleanBodyParam`;
			const $body = encodeValue('application/json',bodyBoolean);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isBoolean)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanBodyParam');
		}
	};
}

function fnSimpleBooleanBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleBooleanBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyBoolean?: boolean) => {
		try {
			const $init = (await preFetch?.('simpleBooleanBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleBooleanBodyParamOpt`;
			const $body = encodeValue('application/json',bodyBoolean);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanBodyParamOpt');
		}
	};
}

function fnSimpleBooleanBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleBooleanBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyBoolean: boolean | null) => {
		try {
			const $init = (await preFetch?.('simpleBooleanBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleBooleanBodyParamNil`;
			const $body = encodeValue('application/json',bodyBoolean);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanBodyParamNil');
		}
	};
}

function fnSimpleBooleanBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleBooleanBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyBoolean?: boolean | null) => {
		try {
			const $init = (await preFetch?.('simpleBooleanBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleBooleanBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyBoolean);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleBooleanBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleBooleanBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleBooleanBodyParamOptNil');
		}
	};
}

function fnSimpleShortBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleShortBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyShort: number) => {
		try {
			const $init = (await preFetch?.('simpleShortBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleShortBodyParam`;
			const $body = encodeValue('application/json',bodyShort);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortBodyParam');
		}
	};
}

function fnSimpleShortBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleShortBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyShort?: number) => {
		try {
			const $init = (await preFetch?.('simpleShortBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleShortBodyParamOpt`;
			const $body = encodeValue('application/json',bodyShort);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortBodyParamOpt');
		}
	};
}

function fnSimpleShortBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleShortBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyShort: number | null) => {
		try {
			const $init = (await preFetch?.('simpleShortBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleShortBodyParamNil`;
			const $body = encodeValue('application/json',bodyShort);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortBodyParamNil');
		}
	};
}

function fnSimpleShortBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleShortBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyShort?: number | null) => {
		try {
			const $init = (await preFetch?.('simpleShortBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleShortBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyShort);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleShortBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleShortBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleShortBodyParamOptNil');
		}
	};
}

function fnSimpleIntBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleIntBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyInt: number) => {
		try {
			const $init = (await preFetch?.('simpleIntBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleIntBodyParam`;
			const $body = encodeValue('application/json',bodyInt);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntBodyParam');
		}
	};
}

function fnSimpleIntBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleIntBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyInt?: number) => {
		try {
			const $init = (await preFetch?.('simpleIntBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleIntBodyParamOpt`;
			const $body = encodeValue('application/json',bodyInt);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntBodyParamOpt');
		}
	};
}

function fnSimpleIntBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleIntBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyInt: number | null) => {
		try {
			const $init = (await preFetch?.('simpleIntBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleIntBodyParamNil`;
			const $body = encodeValue('application/json',bodyInt);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntBodyParamNil');
		}
	};
}

function fnSimpleIntBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleIntBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyInt?: number | null) => {
		try {
			const $init = (await preFetch?.('simpleIntBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleIntBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyInt);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleIntBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleIntBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleIntBodyParamOptNil');
		}
	};
}

function fnSimpleLongBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLongBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLong: number) => {
		try {
			const $init = (await preFetch?.('simpleLongBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLongBodyParam`;
			const $body = encodeValue('application/json',bodyLong);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongBodyParam');
		}
	};
}

function fnSimpleLongBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLongBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLong?: number) => {
		try {
			const $init = (await preFetch?.('simpleLongBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLongBodyParamOpt`;
			const $body = encodeValue('application/json',bodyLong);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongBodyParamOpt');
		}
	};
}

function fnSimpleLongBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLongBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLong: number | null) => {
		try {
			const $init = (await preFetch?.('simpleLongBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLongBodyParamNil`;
			const $body = encodeValue('application/json',bodyLong);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongBodyParamNil');
		}
	};
}

function fnSimpleLongBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLongBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLong?: number | null) => {
		try {
			const $init = (await preFetch?.('simpleLongBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLongBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyLong);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLongBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLongBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLongBodyParamOptNil');
		}
	};
}

function fnSimpleFloatBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleFloatBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyFloat: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleFloatBodyParam`;
			const $body = encodeValue('application/json',bodyFloat);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatBodyParam');
		}
	};
}

function fnSimpleFloatBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleFloatBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyFloat?: number) => {
		try {
			const $init = (await preFetch?.('simpleFloatBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleFloatBodyParamOpt`;
			const $body = encodeValue('application/json',bodyFloat);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatBodyParamOpt');
		}
	};
}

function fnSimpleFloatBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleFloatBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyFloat: number | null) => {
		try {
			const $init = (await preFetch?.('simpleFloatBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleFloatBodyParamNil`;
			const $body = encodeValue('application/json',bodyFloat);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatBodyParamNil');
		}
	};
}

function fnSimpleFloatBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleFloatBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyFloat?: number | null) => {
		try {
			const $init = (await preFetch?.('simpleFloatBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleFloatBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyFloat);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleFloatBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleFloatBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleFloatBodyParamOptNil');
		}
	};
}

function fnSimpleDoubleBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleDoubleBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyDouble: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleDoubleBodyParam`;
			const $body = encodeValue('application/json',bodyDouble);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleBodyParam');
		}
	};
}

function fnSimpleDoubleBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleDoubleBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyDouble?: number) => {
		try {
			const $init = (await preFetch?.('simpleDoubleBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleDoubleBodyParamOpt`;
			const $body = encodeValue('application/json',bodyDouble);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleBodyParamOpt');
		}
	};
}

function fnSimpleDoubleBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleDoubleBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyDouble: number | null) => {
		try {
			const $init = (await preFetch?.('simpleDoubleBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleDoubleBodyParamNil`;
			const $body = encodeValue('application/json',bodyDouble);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleBodyParamNil');
		}
	};
}

function fnSimpleDoubleBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleDoubleBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyDouble?: number | null) => {
		try {
			const $init = (await preFetch?.('simpleDoubleBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleDoubleBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyDouble);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleDoubleBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleDoubleBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleDoubleBodyParamOptNil');
		}
	};
}

function fnSimpleStringBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleStringBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyString: string) => {
		try {
			const $init = (await preFetch?.('simpleStringBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleStringBodyParam`;
			const $body = encodeValue('application/json',bodyString);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringBodyParam');
		}
	};
}

function fnSimpleStringBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleStringBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyString?: string) => {
		try {
			const $init = (await preFetch?.('simpleStringBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleStringBodyParamOpt`;
			const $body = encodeValue('application/json',bodyString);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringBodyParamOpt');
		}
	};
}

function fnSimpleStringBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleStringBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyString: string | null) => {
		try {
			const $init = (await preFetch?.('simpleStringBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleStringBodyParamNil`;
			const $body = encodeValue('application/json',bodyString);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringBodyParamNil');
		}
	};
}

function fnSimpleStringBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleStringBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyString?: string | null) => {
		try {
			const $init = (await preFetch?.('simpleStringBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleStringBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyString);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleStringBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleStringBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleStringBodyParamOptNil');
		}
	};
}

function fnSimpleLocalDateBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDate: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateBodyParam`;
			const $body = encodeValue('application/json',bodyLocalDate);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateBodyParam');
		}
	};
}

function fnSimpleLocalDateBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDate?: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateBodyParamOpt`;
			const $body = encodeValue('application/json',bodyLocalDate);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateBodyParamOpt');
		}
	};
}

function fnSimpleLocalDateBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDate: string | null) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateBodyParamNil`;
			const $body = encodeValue('application/json',bodyLocalDate);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateBodyParamNil');
		}
	};
}

function fnSimpleLocalDateBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDate?: string | null) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyLocalDate);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateBodyParamOptNil');
		}
	};
}

function fnSimpleLocalDateTimeBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateTimeBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateTimeBodyParam`;
			const $body = encodeValue('application/json',bodyLocalDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeBodyParam');
		}
	};
}

function fnSimpleLocalDateTimeBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateTimeBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDateTime?: string) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateTimeBodyParamOpt`;
			const $body = encodeValue('application/json',bodyLocalDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeBodyParamOpt');
		}
	};
}

function fnSimpleLocalDateTimeBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateTimeBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDateTime: string | null) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateTimeBodyParamNil`;
			const $body = encodeValue('application/json',bodyLocalDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeBodyParamNil');
		}
	};
}

function fnSimpleLocalDateTimeBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleLocalDateTimeBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyLocalDateTime?: string | null) => {
		try {
			const $init = (await preFetch?.('simpleLocalDateTimeBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleLocalDateTimeBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyLocalDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleLocalDateTimeBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleLocalDateTimeBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleLocalDateTimeBodyParamOptNil');
		}
	};
}

function fnSimpleZonedDateTimeBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleZonedDateTimeBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyZonedDateTime: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleZonedDateTimeBodyParam`;
			const $body = encodeValue('application/json',bodyZonedDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeBodyParam');
		}
	};
}

function fnSimpleZonedDateTimeBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleZonedDateTimeBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyZonedDateTime?: string) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleZonedDateTimeBodyParamOpt`;
			const $body = encodeValue('application/json',bodyZonedDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeBodyParamOpt');
		}
	};
}

function fnSimpleZonedDateTimeBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleZonedDateTimeBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyZonedDateTime: string | null) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleZonedDateTimeBodyParamNil`;
			const $body = encodeValue('application/json',bodyZonedDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeBodyParamNil');
		}
	};
}

function fnSimpleZonedDateTimeBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleZonedDateTimeBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyZonedDateTime?: string | null) => {
		try {
			const $init = (await preFetch?.('simpleZonedDateTimeBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleZonedDateTimeBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyZonedDateTime);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleZonedDateTimeBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleZonedDateTimeBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleZonedDateTimeBodyParamOptNil');
		}
	};
}

function fnSimpleScalarBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleScalarBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyScalar: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleScalarBodyParam`;
			const $body = encodeValue('application/json',bodyScalar);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarBodyParam');
		}
	};
}

function fnSimpleScalarBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleScalarBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyScalar?: string) => {
		try {
			const $init = (await preFetch?.('simpleScalarBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleScalarBodyParamOpt`;
			const $body = encodeValue('application/json',bodyScalar);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarBodyParamOpt');
		}
	};
}

function fnSimpleScalarBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleScalarBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyScalar: string | null) => {
		try {
			const $init = (await preFetch?.('simpleScalarBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleScalarBodyParamNil`;
			const $body = encodeValue('application/json',bodyScalar);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarBodyParamNil');
		}
	};
}

function fnSimpleScalarBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleScalarBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyScalar?: string | null) => {
		try {
			const $init = (await preFetch?.('simpleScalarBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleScalarBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyScalar);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleScalarBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleScalarBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleScalarBodyParamOptNil');
		}
	};
}

function fnSimpleEnumBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleEnumBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleEnumBodyParam`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isSampleEnum)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumBodyParam');
		}
	};
}

function fnSimpleEnumBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleEnumBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum?: api.model.SampleEnum) => {
		try {
			const $init = (await preFetch?.('simpleEnumBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleEnumBodyParamOpt`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumBodyParamOpt');
		}
	};
}

function fnSimpleEnumBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleEnumBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: api.model.SampleEnum | null) => {
		try {
			const $init = (await preFetch?.('simpleEnumBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleEnumBodyParamNil`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumBodyParamNil');
		}
	};
}

function fnSimpleEnumBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleEnumBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum?: api.model.SampleEnum | null) => {
		try {
			const $init = (await preFetch?.('simpleEnumBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleEnumBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleEnumBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleEnumBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleEnumBodyParamOptNil');
		}
	};
}

function fnSimpleInlineEnumBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleInlineEnumBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: 'A' | 'B') => {
		try {
			const $init = (await preFetch?.('simpleInlineEnumBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleInlineEnumBodyParam`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, isSimpleInlineEnumBodyParamResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleInlineEnumBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleInlineEnumBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleInlineEnumBodyParam');
		}
	};
}

function fnSimpleInlineEnumBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleInlineEnumBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum?: 'A' | 'B') => {
		try {
			const $init = (await preFetch?.('simpleInlineEnumBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleInlineEnumBodyParamOpt`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleInlineEnumBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleInlineEnumBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleInlineEnumBodyParamOpt');
		}
	};
}

function fnSimpleInlineEnumBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleInlineEnumBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum: 'C' | 'D' | null) => {
		try {
			const $init = (await preFetch?.('simpleInlineEnumBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleInlineEnumBodyParamNil`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleInlineEnumBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleInlineEnumBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleInlineEnumBodyParamNil');
		}
	};
}

function fnSimpleInlineEnumBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['simpleInlineEnumBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyEnum?: 'C' | 'D' | null) => {
		try {
			const $init = (await preFetch?.('simpleInlineEnumBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/simpleInlineEnumBodyParamOptNil`;
			const $body = encodeValue('application/json',bodyEnum);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('simpleInlineEnumBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('simpleInlineEnumBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('simpleInlineEnumBodyParamOptNil');
		}
	};
}

function fnMultiBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string, valueB: number, valueC: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('multiBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParam`;
			const $body = encodeValue('application/json', {
				valueA,
				valueB,
				valueC: api.model.SimpleRecordToJSON(valueC),
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParam', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParam');
		}
	};
}

function fnMultiBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA?: string, valueB?: number, valueC?: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('multiBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParamOpt`;
			const $body = encodeValue('application/json', {
				valueA,
				valueB,
				valueC: valueC ? api.model.SimpleRecordToJSON(valueC) : valueC,
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParamOpt');
		}
	};
}

function fnMultiBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string | null, valueB: number | null, valueC: api.model.SimpleRecord | null) => {
		try {
			const $init = (await preFetch?.('multiBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParamNil`;
			const $body = encodeValue('application/json', {
				valueA,
				valueB,
				valueC: valueC ? api.model.SimpleRecordToJSON(valueC) : valueC,
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParamNil');
		}
	};
}

function fnMultiBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA?: string | null, valueB?: number | null, valueC?: api.model.SimpleRecord | null) => {
		try {
			const $init = (await preFetch?.('multiBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParamOptNil`;
			const $body = encodeValue('application/json', {
				valueA,
				valueB,
				valueC: valueC ? api.model.SimpleRecordToJSON(valueC) : valueC,
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParamOptNil');
		}
	};
}

function fnMultiBodyParamFirst(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['multiBodyParamFirst'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (valueA: string | undefined, valueB: number, valueC: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('multiBodyParamFirst')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/multiBodyParamFirst`;
			const $body = encodeValue('application/json', {
				valueA,
				valueB,
				valueC: api.model.SimpleRecordToJSON(valueC),
			});
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('multiBodyParamFirst', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiBodyParamFirst', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiBodyParamFirst');
		}
	};
}

function fnRecordBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['recordBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/recordBodyParam`;
			const $body = encodeValue('application/json', api.model.SimpleRecordToJSON(bodyRecord));
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('recordBodyParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordBodyParam');
		}
	};
}

function fnRecordBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['recordBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord?: api.model.SimpleRecord) => {
		try {
			const $init = (await preFetch?.('recordBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/recordBodyParamOpt`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.SimpleRecordToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('recordBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordBodyParamOpt');
		}
	};
}

function fnRecordBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['recordBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord: api.model.SimpleRecord | null) => {
		try {
			const $init = (await preFetch?.('recordBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/recordBodyParamNil`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.SimpleRecordToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('recordBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordBodyParamNil');
		}
	};
}

function fnRecordBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['recordBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord?: api.model.SimpleRecord | null) => {
		try {
			const $init = (await preFetch?.('recordBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/recordBodyParamOptNil`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.SimpleRecordToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('recordBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('recordBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('recordBodyParamOptNil');
		}
	};
}

function fnUnionBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['unionBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyUnion: api.model.Union) => {
		try {
			const $init = (await preFetch?.('unionBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/unionBodyParam`;
			const $body = encodeValue('application/json', api.model.UnionToJSON(bodyUnion));
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.UnionFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('unionBodyParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('unionBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('unionBodyParam');
		}
	};
}

function fnUnionBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['unionBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyUnion?: api.model.Union) => {
		try {
			const $init = (await preFetch?.('unionBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/unionBodyParamOpt`;
			const $body = encodeValue('application/json', bodyUnion ? api.model.UnionToJSON(bodyUnion) : bodyUnion);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('unionBodyParamOpt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('unionBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('unionBodyParamOpt');
		}
	};
}

function fnUnionBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['unionBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyUnion: api.model.Union | null) => {
		try {
			const $init = (await preFetch?.('unionBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/unionBodyParamNil`;
			const $body = encodeValue('application/json', bodyUnion ? api.model.UnionToJSON(bodyUnion) : bodyUnion);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('unionBodyParamNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('unionBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('unionBodyParamNil');
		}
	};
}

function fnUnionBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['unionBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyUnion?: api.model.Union | null) => {
		try {
			const $init = (await preFetch?.('unionBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/unionBodyParamOptNil`;
			const $body = encodeValue('application/json', bodyUnion ? api.model.UnionToJSON(bodyUnion) : bodyUnion);
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isNilResult)
				return safeExecute(api.result.OK($data), () => onSuccess?.('unionBodyParamOptNil', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('unionBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('unionBodyParamOptNil');
		}
	};
}

function fnPatchableRecordBodyParam(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['patchableRecordBodyParam'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord: api.model.PatchableRecordPatch) => {
		try {
			const $init = (await preFetch?.('patchableRecordBodyParam')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/patchableRecordBodyParam`;
			const $body = encodeValue('application/json', api.model.PatchableRecordPatchToJSON(bodyRecord));
			const $response = await fetchAPI($path, { ...$init, method: 'PATCH', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.PatchableRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('patchableRecordBodyParam', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('patchableRecordBodyParam', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('patchableRecordBodyParam');
		}
	};
}

function fnPatchableRecordBodyParamOpt(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['patchableRecordBodyParamOpt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord?: api.model.PatchableRecordPatch) => {
		try {
			const $init = (await preFetch?.('patchableRecordBodyParamOpt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/patchableRecordBodyParamOpt`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.PatchableRecordPatchToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'PATCH', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.PatchableRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('patchableRecordBodyParamOpt', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('patchableRecordBodyParamOpt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('patchableRecordBodyParamOpt');
		}
	};
}

function fnPatchableRecordBodyParamNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['patchableRecordBodyParamNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord: api.model.PatchableRecordPatch | null) => {
		try {
			const $init = (await preFetch?.('patchableRecordBodyParamNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/patchableRecordBodyParamNil`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.PatchableRecordPatchToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'PATCH', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.PatchableRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('patchableRecordBodyParamNil', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('patchableRecordBodyParamNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('patchableRecordBodyParamNil');
		}
	};
}

function fnPatchableRecordBodyParamOptNil(props: ServiceProps<api.service.ErrorType>): api.service.BodyParameterTypesService['patchableRecordBodyParamOptNil'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (bodyRecord?: api.model.PatchableRecordPatch | null) => {
		try {
			const $init = (await preFetch?.('patchableRecordBodyParamOptNil')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/bodyparametertypes/patchableRecordBodyParamOptNil`;
			const $body = encodeValue('application/json', bodyRecord ? api.model.PatchableRecordPatchToJSON(bodyRecord) : bodyRecord);
			const $response = await fetchAPI($path, { ...$init, method: 'PATCH', body: $body });
			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.PatchableRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('patchableRecordBodyParamOptNil', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('patchableRecordBodyParamOptNil', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('patchableRecordBodyParamOptNil');
		}
	};
}

