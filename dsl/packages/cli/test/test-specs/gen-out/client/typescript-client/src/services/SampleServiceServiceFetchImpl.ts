// Generated by RSD - Do not modify
import { decodeResponse, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createSampleServiceService(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService {
	return {
		getBoolean: fnGetBoolean(props),
		getShort: fnGetShort(props),
		getInt: fnGetInt(props),
		getLong: fnGetLong(props),
		getFloat: fnGetFloat(props),
		getDouble: fnGetDouble(props),
		getString: fnGetString(props),
		getLocalDate: fnGetLocalDate(props),
		getLocalDateTime: fnGetLocalDateTime(props),
		getZonedDateTime: fnGetZonedDateTime(props),
		getScalar: fnGetScalar(props),
		getEnum: fnGetEnum(props),
		voidOperation: fnVoidOperation(props),
		errorOperation: fnErrorOperation(props),
		multiErrorOperation: fnMultiErrorOperation(props),
		getSimpleRecord: fnGetSimpleRecord(props),
		getSimpleRecordWithError: fnGetSimpleRecordWithError(props),
	};
}
function fnGetBoolean(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getBoolean'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getBoolean')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/boolean`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isBoolean)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getBoolean', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getBoolean', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getBoolean');
		}
	};
}

function fnGetShort(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getShort'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getShort')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/short`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getShort', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getShort', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getShort');
		}
	};
}

function fnGetInt(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getInt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getInt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/int`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getInt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getInt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getInt');
		}
	};
}

function fnGetLong(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getLong'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getLong')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/long`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getLong', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getLong', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getLong');
		}
	};
}

function fnGetFloat(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getFloat'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getFloat')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/float`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getFloat', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getFloat', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getFloat');
		}
	};
}

function fnGetDouble(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getDouble'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getDouble')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/double`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isNumber)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getDouble', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getDouble', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getDouble');
		}
	};
}

function fnGetString(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getString'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getString')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/string`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getString', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getString', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getString');
		}
	};
}

function fnGetLocalDate(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getLocalDate'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getLocalDate')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/localdate`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getLocalDate', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getLocalDate', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getLocalDate');
		}
	};
}

function fnGetLocalDateTime(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getLocalDateTime'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getLocalDateTime')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/localdatetime`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getLocalDateTime', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getLocalDateTime', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getLocalDateTime');
		}
	};
}

function fnGetZonedDateTime(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getZonedDateTime'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getZonedDateTime')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/zoneddatetime`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getZonedDateTime', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getZonedDateTime', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getZonedDateTime');
		}
	};
}

function fnGetScalar(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getScalar'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getScalar')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/scalar`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isString)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getScalar', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getScalar', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getScalar');
		}
	};
}

function fnGetEnum(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getEnum'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('getEnum')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/enum`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.model.isSampleEnum)
				return safeExecute(api.result.OK($data), () => onSuccess?.('getEnum', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getEnum', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getEnum');
		}
	};
}

function fnVoidOperation(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['voidOperation'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('voidOperation')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/voidoperation`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 204) {
				return safeExecute(api.result.OK(api.result.Void), () => onSuccess?.('voidOperation', api.result.Void));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('voidOperation', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('voidOperation');
		}
	};
}

function fnErrorOperation(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['errorOperation'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('errorOperation')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/erroroperation`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				return safeExecute(api.result.OK(api.result.Void), () => onSuccess?.('errorOperation', api.result.Void));
			} else if ($response.status === 400) {
				const err = {
					_type: 'SampleError',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('errorOperation', err));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('errorOperation', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('errorOperation');
		}
	};
}

function fnMultiErrorOperation(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['multiErrorOperation'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('multiErrorOperation')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/multierroroperation`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				return safeExecute(api.result.OK(api.result.Void), () => onSuccess?.('multiErrorOperation', api.result.Void));
			} else if ($response.status === 400) {
				const err = {
					_type: 'SampleError',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('multiErrorOperation', err));
			} else if ($response.status === 401) {
				const err = {
					_type: 'SampleError2',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('multiErrorOperation', err));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('multiErrorOperation', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('multiErrorOperation');
		}
	};
}

function fnGetSimpleRecord(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getSimpleRecord'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async (key: string) => {
		try {
			const $init = (await preFetch?.('getSimpleRecord')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/simplerecord/${encodeURIComponent(key)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('getSimpleRecord', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getSimpleRecord', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getSimpleRecord');
		}
	};
}

function fnGetSimpleRecordWithError(props: ServiceProps<api.service.ErrorType>): api.service.SampleServiceService['getSimpleRecordWithError'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async (key: string) => {
		try {
			const $init = (await preFetch?.('getSimpleRecordWithError')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/samplerecords/simplerecordwitherror/${encodeURIComponent(key)}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, api.utils.isRecord)
				const $result = api.model.SimpleRecordFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('getSimpleRecordWithError', $result));
			} else if ($response.status === 400) {
				const err = {
					_type: 'SampleError',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('getSimpleRecordWithError', err));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('getSimpleRecordWithError', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('getSimpleRecordWithError');
		}
	};
}

