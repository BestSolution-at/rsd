// Generated by RSD - Do not modify
import { decodeResponse, safeExecute, type ServiceProps } from './_fetch-type-utils.js';
import { api } from '../index.js';

export function createListSampleServiceService(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService {
	return {
		listBoolean: fnListBoolean(props),
		listShort: fnListShort(props),
		listInt: fnListInt(props),
		listLong: fnListLong(props),
		listFloat: fnListFloat(props),
		listDouble: fnListDouble(props),
		listString: fnListString(props),
		listLocalDate: fnListLocalDate(props),
		listLocalDateTime: fnListLocalDateTime(props),
		listZonedDateTime: fnListZonedDateTime(props),
		listScalar: fnListScalar(props),
		listEnum: fnListEnum(props),
		listSimpleRecord: fnListSimpleRecord(props),
		listSimpleRecordWithError: fnListSimpleRecordWithError(props),
	};
}
function fnListBoolean(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listBoolean'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listBoolean')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/boolean`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isBoolean))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listBoolean', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listBoolean', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listBoolean');
		}
	};
}

function fnListShort(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listShort'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listShort')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/short`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listShort', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listShort', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listShort');
		}
	};
}

function fnListInt(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listInt'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listInt')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/int`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listInt', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listInt', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listInt');
		}
	};
}

function fnListLong(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listLong'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listLong')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/long`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLong', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLong', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLong');
		}
	};
}

function fnListFloat(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listFloat'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listFloat')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/float`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listFloat', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listFloat', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listFloat');
		}
	};
}

function fnListDouble(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listDouble'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listDouble')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/double`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isNumber))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listDouble', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listDouble', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listDouble');
		}
	};
}

function fnListString(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listString'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listString')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/string`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listString', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listString', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listString');
		}
	};
}

function fnListLocalDate(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listLocalDate'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listLocalDate')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/localdate`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDate', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDate', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDate');
		}
	};
}

function fnListLocalDateTime(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listLocalDateTime'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listLocalDateTime')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/localdatetime`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listLocalDateTime', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listLocalDateTime', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listLocalDateTime');
		}
	};
}

function fnListZonedDateTime(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listZonedDateTime'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listZonedDateTime')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/zoneddatetime`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listZonedDateTime', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listZonedDateTime', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listZonedDateTime');
		}
	};
}

function fnListScalar(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listScalar'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listScalar')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/scalar`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isString))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listScalar', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listScalar', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listScalar');
		}
	};
}

function fnListEnum(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listEnum'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listEnum')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/enum`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.model.isSampleEnum))
				return safeExecute(api.result.OK($data), () => onSuccess?.('listEnum', $data));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listEnum', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listEnum');
		}
	};
}

function fnListSimpleRecord(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listSimpleRecord'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listSimpleRecord')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/simplerecord`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isRecord))
				const $result = $data.map(api.model.SimpleRecordFromJSON);
				return safeExecute(api.result.OK($result), () => onSuccess?.('listSimpleRecord', $result));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listSimpleRecord', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listSimpleRecord');
		}
	};
}

function fnListSimpleRecordWithError(props: ServiceProps<api.service.ErrorType>): api.service.ListSampleServiceService['listSimpleRecordWithError'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async () => {
		try {
			const $init = (await preFetch?.('listSimpleRecordWithError')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/listsamplerecords/simplerecordwitherror`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if ($response.status === 200) {
				const $data = await decodeResponse($response, v => api.utils.isTypedArray(v, api.utils.isRecord))
				const $result = $data.map(api.model.SimpleRecordFromJSON);
				return safeExecute(api.result.OK($result), () => onSuccess?.('listSimpleRecordWithError', $result));
			} else if ($response.status === 400) {
				const err = {
					_type: 'SampleError',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('listSimpleRecordWithError', err));
			}
			const err = { _type: '_Status', message: await $response.text(), status: $response.status } as const;
			return api.result.ERR(err);
		} catch (e) {
			onCatch?.('listSimpleRecordWithError', e);
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee } as const;
			return api.result.ERR(err);
		} finally {
			final?.('listSimpleRecordWithError');
		}
	};
}

