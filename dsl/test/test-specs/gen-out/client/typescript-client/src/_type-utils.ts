// Generated by RSD - Do not modify
export function isDefined<T>(value: T | undefined): value is T {
	return value !== undefined;
}

export function isUndefined<T>(value: T | undefined): value is undefined {
	return value === undefined;
}

export function isNotNull<T>(value: T | null): value is T {
	return value !== null;
}

export function isNull<T>(value: T | null): value is null {
	return value === null;
}

export function isValue<T>(value: T | undefined | null): value is T {
	return isNotNull(value) && isDefined(value);
}

export function isBoolean(value: unknown): value is boolean {
	return typeof value === 'boolean';
}

export function isNumber(value: unknown): value is number {
	return typeof value === 'number';
}

export function isArray(value: unknown): value is Array<unknown> {
	return isNotNull(value) && isDefined(value) && Array.isArray(value);
}

export function isRecord(value: unknown): value is Record<string, unknown> {
	return isNotNull(value) && typeof value === 'object' && !isArray(value);
}

export function isString(value: unknown): value is string {
	return typeof value === 'string';
}

export function isStringType<T extends string>(value: unknown, type: T): value is T {
	return value === type;
}

export function createIsStringTypeGuard<T extends string>(type: T): (v: unknown) => v is T {
	return v => isStringType(v, type);
}

export function createTypedArrayGuard<T>(guard: (v: unknown) => v is T): (v: unknown) => v is T[] {
	return v => isTypedArray(v, guard);
}

export function isTypedArray<T>(value: unknown, guard: (v: unknown) => v is T): value is Array<T> {
	if (isArray(value)) {
		if (value.length === 0) {
			return true;
		}
		return value.find(guard) === undefined;
	}
	return false;
}

export class PropertyCheckError extends Error {
	readonly property: string;
	readonly record: Record<string, unknown>;

	constructor(message: string, property: string, record: Record<string, unknown>) {
		super(message);
		this.property = property;
		this.record = record;
	}
}

export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T): T;
export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'optional'): T | undefined;
export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'null'): T | null;
export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'optional_null'): T | null | undefined;
export function propValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow?: 'optional' | 'null' | 'optional_null'): T | null | undefined {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (guard(v)) {
		return v;
	}

	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T): T[];
export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'optional'): T[] | undefined;
export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'null'): T[] | null;
export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow: 'optional_null'): T[] | undefined | null;
export function propListValue<T>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, allow?: 'optional' | 'null' | 'optional_null'): T[] | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow == 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (isTypedArray(v, guard)) {
		return v;
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propMappedValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U): U;
export function propMappedValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow: 'optional'): U | undefined;
export function propMappedValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow: 'null'): U | null;
export function propMappedValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow: 'optional_null'): U | undefined | null;
export function propMappedValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow?: 'optional' | 'null' | 'optional_null'): U | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (guard(v)) {
		return map(v);
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function propMappedListValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow?: 'optional' | 'null' | 'optional_null'): U[];
export function propMappedListValue<T, U>(name: string, record: Record<string, unknown>, guard: (v: unknown) => v is T, map: (v: T) => U, allow?: 'optional' | 'null' | 'optional_null'): U[] | undefined | null {
	const v = record[name];
	if (allow === 'optional' || allow === 'optional_null') {
		if (isUndefined(v)) {
			return undefined;
		}
	}
	if (allow === 'null' || allow === 'optional_null') {
		if (isNull(v)) {
			return null;
		}
	}
	if (isTypedArray(v, guard)) {
		return v.map(map);
	}
	throw new PropertyCheckError(`Value in property ${name} is invalid`, name, record);
}

export function checkProp<T, K extends string>(value: Record<string, unknown>, property: K, typeCheck: (value: unknown) => value is T, valueCheck?: (value: T) => boolean): value is Record<string, unknown> {
	if (property in value) {
		const v = value[property];
		return (
			v !== undefined && //
			v !== null &&
			typeCheck(v) &&
			(valueCheck === undefined || valueCheck(v))
		);
	}
	return false;
}

export function checkOptProp<T, K extends string>(value: Record<string, unknown>, property: K, typeCheck: (value: unknown) => value is T, valueCheck?: (value: T) => boolean): value is Record<string, unknown> {
	if (!(property in value)) {
		return true;
	}
	return checkProp(value, property, typeCheck, valueCheck);
}

function checkListProp<T, K extends string>(value: Record<string, unknown>, property: K, typeCheck: (value: unknown) => value is T, valueCheck?: (value: T) => boolean): value is Record<string, unknown> {
	return checkProp(
		value,
		property,
		isArray,
		arr =>
			arr.find(v => {
				if (typeCheck(v)) {
					if (valueCheck === undefined) {
						return false;
					} else {
						return !valueCheck(v);
					}
				} else {
					return true;
				}
			}) === undefined
	);
}

export type ListReplace<T> = {
	'@type': 'replace';
	readonly elements: readonly T[];
};

export type ListMergeAddRemove<A, R> = {
	'@type': 'merge';
	readonly additions: readonly A[];
	readonly removals: readonly R[];
};

export type ListMergeAddUpdateRemove<A, U, R> = {
	'@type': 'merge';
	readonly additions: readonly A[];
	readonly updates: readonly U[];
	readonly removals: readonly R[];
};

export function isListReplace<T>(value: unknown, typeCheck: (value: unknown) => value is T): value is ListReplace<T> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'replace') &&
		checkListProp(value, 'elements', typeCheck)
	);
}

export function isListMergeAddRemove<A, R>(value: unknown, addTypeCheck: (value: unknown) => value is A, removeTypeCheck: (value: unknown) => value is R): value is ListMergeAddRemove<A, R> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'merge') &&
		checkListProp(value, 'additions', addTypeCheck) &&
		checkListProp(value, 'removals', removeTypeCheck)
	);
}

export function isListMergeAddUpdateRemove<A, U, R>(value: unknown, addTypeCheck: (value: unknown) => value is A, updateTypeCheck: (value: unknown) => value is U, removeTypeCheck: (value: unknown) => value is R): value is ListMergeAddUpdateRemove<A, U, R> {
	return (
		isRecord(value) && //
		checkProp(value, '@type', isString, v => v === 'merge') &&
		checkListProp(value, 'additions', addTypeCheck) &&
		checkListProp(value, 'updates', updateTypeCheck) &&
		checkListProp(value, 'removals', removeTypeCheck)
	);
}

export function ListReplaceFromJSON<T, U>(value: Record<string, unknown>, typeGuard: (v: unknown) => v is U, map: (v: U) => T): ListReplace<T> {
	const elements = propMappedListValue('elements', value, typeGuard, map);
	return {
		'@type': 'replace',
		elements,
	};
}

export function ListReplaceToJSON<T>(value: ListReplace<T>, map: (value: T) => JsonValue) {
	const elements = value.elements.map(map);
	return {
		'@type': 'replace',
		elements,
	};
}

export function ListMergeAddRemoveFromJSON<A, X, R, Y>(value: Record<string, unknown>, addTypeGuard: (v: unknown) => v is X, addMap: (v: X) => A, removeTypeGuard: (v: unknown) => v is Y, removeMap: (v: Y) => R): ListMergeAddRemove<A, R> {
	const additions = propMappedListValue('additions', value, addTypeGuard, addMap);
	const removals = propMappedListValue('removals', value, removeTypeGuard, removeMap);
	return {
		'@type': 'merge',
		additions,
		removals,
	};
}

export function ListMergeAddRemoveToJSON<A, R>(value: ListMergeAddRemove<A, R>, addMap: (value: A) => unknown, removeMap: (value: R) => unknown) {
	const additions = value.additions.map(addMap);
	const removals = value.removals.map(removeMap);
	return {
		'@type': 'merge',
		additions,
		removals,
	};
}

export function ListMergeAddUpdateRemoveFromJSON<A, X, U, Y, R, Z>(value: Record<string, unknown>, addTypeGuard: (v: unknown) => v is X, addMap: (v: X) => A, updateTypeGuard: (v: unknown) => v is Y, updateMap: (v: Y) => U, removeTypeGuard: (v: unknown) => v is Z, removeMap: (v: Z) => R): ListMergeAddUpdateRemove<A, U, R> {
	const additions = propMappedListValue('additions', value, addTypeGuard, addMap);
	const updates = propMappedListValue('updates', value, updateTypeGuard, updateMap);
	const removals = propMappedListValue('removals', value, removeTypeGuard, removeMap);
	return {
		'@type': 'merge',
		additions,
		updates,
		removals,
	};
}

export function ListMergeAddUpdateRemoveToJSON<A, U, R>(value: ListMergeAddUpdateRemove<A, U, R>, addMap: (value: A) => unknown, updateMap: (value: U) => unknown, removeMap: (value: R) => unknown) {
	const additions = value.additions.map(addMap);
	const updates = value.updates.map(updateMap);
	const removals = value.removals.map(removeMap);
	return {
		'@type': 'merge',
		additions,
		updates,
		removals,
	};
}

export function SetOrPatchChangeFromJSON<S, P>(value: Record<string, unknown>, setMapper: (value: Record<string, unknown>) => S, patchMapper: (value: Record<string, unknown>) => P): S | P {
	if (value['@type'] === 'replace') {
		return setMapper(value);
	}
	return patchMapper(value);
}

export function noopMap<T>(v: T): T {
	return v;
}

type JsonValue =
	| undefined //
	| null
	| string
	| number
	| boolean
	| JsonObject
	| JsonArray;

type JsonObject = {
	[x: string]: JsonValue;
};

type JsonArray = Array<JsonValue>;
